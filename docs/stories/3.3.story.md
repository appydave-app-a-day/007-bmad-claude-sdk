# Story 3.3: Build Chat Interface with Vercel AI Elements

## Status

Draft

## Story

**As a** developer,
**I want** a chat interface using Vercel AI Elements patterns,
**so that** users can send messages and see streaming agent responses in a familiar chat UI.

## Acceptance Criteria

1. Vercel AI SDK UI patterns applied (chat interface layout, message bubbles, input design) - Socket.io handles streaming, not Vercel's built-in streaming
2. Chat interface component created with message list and input field
3. Message display shows user messages and agent responses with clear visual distinction
4. Text input field with send button for user messages
5. Messages displayed in scrollable area with automatic scroll to latest message
6. Socket.io client integrated to send/receive messages
7. User message triggers `user_message` Socket event to server
8. Agent responses received via `agent_response_chunk` Socket events displayed in real-time
9. Streaming responses append chunks to current agent message (not create new messages per chunk)
10. Loading/typing indicator shown while agent is processing
11. Message history persists during session (cleared on page refresh)
12. Keyboard shortcut: Enter key sends message, Shift+Enter adds new line

## Tasks / Subtasks

- [ ] Task 1: Create shared types for chat messages and socket events (AC: 1, 6, 7, 8)
  - [ ] Navigate to `packages/shared/src/types.ts`
  - [ ] Define `ChatMessage` interface with id, role, content, timestamp, status fields
  - [ ] Define socket event payload types: `UserMessageEvent`, `AgentResponseChunkEvent`, `AgentResponseCompleteEvent`, `ErrorEvent`
  - [ ] Export union type `SocketEvent` for all event types
  - [ ] Verify TypeScript compilation succeeds: `npm run build -w @bmad-app/shared`

- [ ] Task 2: Create Socket.io client setup and hook (AC: 6, 7, 8)
  - [ ] Create `packages/client/src/lib/socket.ts` with `createSocket()` function
  - [ ] Configure Socket.io client with auto-connect, reconnection settings, server URL from env
  - [ ] Add event handlers for connect, disconnect, connect_error events with console logging
  - [ ] Create `packages/client/src/hooks/useSocket.ts` custom hook
  - [ ] Implement socket lifecycle management (initialize, cleanup on unmount)
  - [ ] Add connection state tracking (isConnected, isStreaming)
  - [ ] Implement `sendMessage(content, messageId)` callback that emits `user_message` event
  - [ ] Add event listeners for `agent_response_chunk`, `agent_response_complete`, `error` events
  - [ ] Pass event handlers via options pattern (onChunk, onComplete, onError callbacks)
  - [ ] Verify socket connects to server successfully in browser dev tools

- [ ] Task 3: Create chat state management hook (AC: 2, 9, 11)
  - [ ] Create `packages/client/src/hooks/useChat.ts` custom hook
  - [ ] Initialize messages state array with useState (ChatMessage[])
  - [ ] Implement `addMessage(message)` function to append user messages
  - [ ] Implement `updateLastMessage(messageId, chunk)` function for streaming:
    - Check if last message is assistant role
    - If yes, append chunk to existing content
    - If no, create new assistant message with chunk as initial content
  - [ ] Implement `clearHistory()` function to reset messages array
  - [ ] Return state and functions: { messages, addMessage, updateLastMessage, clearHistory }
  - [ ] Verify state updates correctly with React DevTools

- [ ] Task 4: Create MessageItem component for individual message bubbles (AC: 3)
  - [ ] Create `packages/client/src/components/chat/MessageItem.tsx`
  - [ ] Accept props: message (ChatMessage type), isStreaming (boolean)
  - [ ] Apply conditional styling based on message.role:
    - User messages: Right-aligned, primary background color
    - Assistant messages: Left-aligned, muted background color
  - [ ] Use shadcn/ui Card component for message bubble structure
  - [ ] Display message.content with markdown support (simple text for MVP)
  - [ ] Add timestamp display (formatted as HH:MM)
  - [ ] Apply Tailwind classes for spacing, padding, border-radius
  - [ ] Export component with proper TypeScript types

- [ ] Task 5: Create MessageList component for scrollable message display (AC: 2, 5)
  - [ ] Create `packages/client/src/components/chat/MessageList.tsx`
  - [ ] Accept props: messages (ChatMessage[])
  - [ ] Use shadcn/ui ScrollArea component for scrollable container
  - [ ] Map over messages array and render MessageItem for each
  - [ ] Implement auto-scroll to bottom using useEffect + ref:
    - Create scrollRef with useRef
    - useEffect dependency on messages.length
    - Call scrollRef.current.scrollIntoView({ behavior: 'smooth' })
  - [ ] Add empty state when messages.length === 0 (welcome message)
  - [ ] Apply flex column layout with gap spacing
  - [ ] Export component with proper TypeScript types

- [ ] Task 6: Create TypingIndicator component for loading state (AC: 10)
  - [ ] Create `packages/client/src/components/chat/TypingIndicator.tsx`
  - [ ] Render animated dots (three dots with staggered animation)
  - [ ] Use Tailwind CSS for pulse animation or CSS keyframes
  - [ ] Apply muted text color and left alignment (matches assistant messages)
  - [ ] Add aria-live="polite" for accessibility
  - [ ] Export component (no props needed)

- [ ] Task 7: Create MessageInput component for user input (AC: 4, 12)
  - [ ] Create `packages/client/src/components/chat/MessageInput.tsx`
  - [ ] Accept props: onSend (callback), disabled (boolean)
  - [ ] Use shadcn/ui Input component for text input field
  - [ ] Use shadcn/ui Button component for send button
  - [ ] Implement controlled input with useState for input value
  - [ ] Implement handleSend function:
    - Trim input value
    - If empty, do nothing
    - Call onSend(value)
    - Clear input field
  - [ ] Add Enter key handler: if !shiftKey, call handleSend (AC: 12)
  - [ ] Add Shift+Enter support: allow newline in input (use textarea instead of input)
  - [ ] Disable input and button when disabled prop is true
  - [ ] Add placeholder text: "Type a message..."
  - [ ] Apply Tailwind classes for layout (flex row, gap, padding)
  - [ ] Export component with proper TypeScript types

- [ ] Task 8: Create ChatInterface main component (AC: 1, 2)
  - [ ] Create `packages/client/src/components/chat/ChatInterface.tsx`
  - [ ] Import all chat subcomponents: MessageList, MessageInput, TypingIndicator
  - [ ] Import ThemeToggle from ui components (Story 3.4 placeholder - can skip if not ready)
  - [ ] Import useSocket and useChat hooks
  - [ ] Initialize useChat hook to get messages state and functions
  - [ ] Initialize useSocket hook with event handlers:
    - onChunk: call updateLastMessage(messageId, chunk)
    - onComplete: mark message as complete (update status)
    - onError: display error message or log to console
  - [ ] Implement handleSendMessage function:
    - Generate messageId with crypto.randomUUID()
    - Create user message object with current timestamp
    - Call addMessage to add user message to state
    - Call sendMessage from useSocket to emit event to server
  - [ ] Render layout structure:
    - Header with title "BMAD + Claude SDK" and ThemeToggle (if available)
    - MessageList component with messages prop
    - TypingIndicator component (conditionally render if isStreaming)
    - MessageInput component with onSend and disabled props
  - [ ] Apply Tailwind classes for full-height layout (flex flex-col h-screen)
  - [ ] Export component

- [ ] Task 9: Update App.tsx to use ChatInterface (AC: 1)
  - [ ] Navigate to `packages/client/src/App.tsx`
  - [ ] Remove test component code from Story 3.2
  - [ ] Import ChatInterface component
  - [ ] Render ChatInterface as root component
  - [ ] Remove any Card/Button test components
  - [ ] Verify TypeScript compilation succeeds

- [ ] Task 10: Create environment variable configuration (AC: 6)
  - [ ] Create `packages/client/.env.example` with VITE_SOCKET_URL variable
  - [ ] Set default value: `VITE_SOCKET_URL=http://localhost:3000`
  - [ ] Update `packages/client/src/lib/socket.ts` to use: `import.meta.env.VITE_SOCKET_URL`
  - [ ] Document in README that server must be running on port 3000
  - [ ] Add .env to .gitignore if not already present

- [ ] Task 11: Verify integration and test chat workflow (AC: all)
  - [ ] Start server: `npm run dev -w @bmad-app/server` (ensure server from Story 1.4 is running)
  - [ ] Start Vite dev server: `npm run dev -w @bmad-app/client`
  - [ ] Open browser to `http://localhost:5173`
  - [ ] Verify Socket.io connection successful (check browser console for "Connected" message)
  - [ ] Test user message send: Type message, click Send button
  - [ ] Verify `user_message` event emitted (check server console logs)
  - [ ] Verify user message appears in message list with right alignment
  - [ ] Verify agent response chunks appear in real-time (left-aligned)
  - [ ] Verify typing indicator shows while streaming
  - [ ] Verify multiple messages accumulate in message list
  - [ ] Verify Enter key sends message, Shift+Enter adds newline
  - [ ] Verify auto-scroll to latest message works
  - [ ] Check browser console for any errors or warnings
  - [ ] Verify connection status updates on server disconnect/reconnect
  - [ ] Build production bundle: `npm run build -w @bmad-app/client`
  - [ ] Test production build via Express: `http://localhost:3000/chat`
  - [ ] Commit changes with message: "Complete Story 3.3: Build Chat Interface with Vercel AI Elements"

## Dev Notes

This story builds the core chat interface using Vercel AI SDK UI patterns (layout and component structure) while Socket.io handles the actual streaming communication. The implementation creates a professional chat UI with message bubbles, real-time streaming display, auto-scroll, and keyboard shortcuts.

### Previous Story Insights

**From Story 3.2 (Install shadcn/ui and Configure TailwindCSS):**
- âœ… **shadcn/ui components ready** - Button, Input, Card, ScrollArea installed and tested
- âœ… **TailwindCSS configured** - Theme variables, dark mode support, path aliases (@/) working
- âœ… **Production build verified** - Vite compiles CSS successfully, Express serves React bundle
- ðŸ“ **Current state**: Test component renders shadcn/ui components, no chat functionality yet
- ðŸ“ **Next step**: Replace test component with ChatInterface using installed UI components

**From Story 3.1 (Initialize React + Vite Application):**
- âœ… **React 19 + Vite 7 ready** - HMR working, TypeScript configured
- âœ… **Dual-mode workflow** - Vite dev server (5173) for development, Express (3000) for production
- ðŸ“ **Environment setup**: Vite dev mode runs independently, production mode served by Express at /chat route

**From Story 1.4 (Implement Socket.io for Real-Time Communication):**
- âœ… **Socket.io server ready** - WebSocket server running on port 3000
- âœ… **Event structure defined** - `user_message` (clientâ†’server), `agent_response_chunk` (serverâ†’client)
- ðŸ“ **Integration point**: Client needs to connect to existing Socket.io server and handle events
- ðŸ“ **Testing approach**: Server logs show Socket.io events for debugging

**From Epic 3 Goal:**
- ðŸ“ **Vercel AI Elements**: Use UI patterns and component structure, NOT Vercel's streaming library (Socket.io handles streaming)
- ðŸ“ **Story 3.4 dependency**: ThemeToggle component will be created in next story - can add placeholder or skip for now
- ðŸ“ **Production-quality**: Professional chat UI ready for video demonstration

**Key Lessons:**
- Socket.io client must reconnect automatically (config: reconnection: true, reconnectionAttempts: 5)
- Streaming updates require careful state management (append chunks to existing message, not create new messages)
- Auto-scroll to bottom needs ref + useEffect pattern to avoid scroll fighting during streaming
- Message bubbles need clear visual distinction (user: right-aligned primary color, assistant: left-aligned muted)
- Keyboard shortcuts (Enter/Shift+Enter) improve UX significantly

[Source: docs/stories/3.2.story.md#Dev Notes, docs/stories/3.1.story.md#Dev Notes, docs/stories/1.4.story.md#Dev Notes, docs/prd/epic-3-react-frontend-with-chat-interface.md]

### Tech Stack

**Frontend Framework:**
- **React**: Version 19.x - Component framework for chat UI
- **TypeScript**: 5.7+ - Type-safe development with shared types
- **Vite**: 7.x - Dev server with HMR for rapid development
- [Source: docs/architecture/tech-stack.md#Frontend Framework]

**UI Component Library:**
- **shadcn/ui**: Latest - Base components (Button, Input, Card, ScrollArea) used for chat UI
- **TailwindCSS**: 4.x - Utility-first styling for message bubbles, layout, spacing
- **Rationale**: shadcn/ui provides accessible, professional components without vendor lock-in; TailwindCSS enables rapid styling with theme consistency
- [Source: docs/architecture/tech-stack.md#UI Component Library]

**Real-Time Communication:**
- **Socket.io-client**: 4.x - WebSocket client for bidirectional communication
- **Event-based**: Custom events (user_message, agent_response_chunk, agent_response_complete, error)
- **Auto-reconnection**: Built-in reconnection logic with configurable retry attempts
- **Rationale**: Socket.io provides reliable WebSocket communication with automatic fallbacks, perfect for streaming agent responses
- [Source: docs/architecture/tech-stack.md#API Style]

**State Management:**
- **React useState**: Built-in hook for chat message state
- **Custom hooks**: useChat (message state), useSocket (Socket.io client lifecycle)
- **No global state library**: Redux/Zustand unnecessary for MVP (simple message array state)
- **Rationale**: Built-in React hooks sufficient for chat state, custom hooks encapsulate concerns cleanly
- [Source: docs/architecture/tech-stack.md#State Management]

**Vercel AI SDK UI:**
- **Purpose**: UI patterns and component structure inspiration ONLY
- **NOT using**: Vercel's built-in streaming library or useChat hook
- **Socket.io handles streaming**: Custom implementation with Socket.io, not Vercel's streaming primitives
- **Rationale**: Vercel AI Elements provide proven chat UI patterns, but Socket.io integration already exists (Story 1.4)
- [Source: docs/prd/epic-3-react-frontend-with-chat-interface.md#Story 3.3, docs/architecture/tech-stack.md]

### Project Structure

**Files Created in This Story:**

```
packages/shared/src/
â””â”€â”€ types.ts                       # Shared TypeScript types (ChatMessage, SocketEvent)

packages/client/src/
â”œâ”€â”€ components/
â”‚   â””â”€â”€ chat/
â”‚       â”œâ”€â”€ ChatInterface.tsx      # Main chat container component
â”‚       â”œâ”€â”€ MessageList.tsx        # Scrollable message display with auto-scroll
â”‚       â”œâ”€â”€ MessageItem.tsx        # Individual message bubble (user/assistant styling)
â”‚       â”œâ”€â”€ MessageInput.tsx       # Text input + send button (Enter/Shift+Enter support)
â”‚       â””â”€â”€ TypingIndicator.tsx    # Loading dots animation during streaming
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useSocket.ts               # Socket.io client lifecycle hook
â”‚   â””â”€â”€ useChat.ts                 # Chat state management hook
â””â”€â”€ lib/
    â””â”€â”€ socket.ts                  # Socket.io client initialization

packages/client/
â””â”€â”€ .env.example                   # Environment variable template
```

**Files Modified in This Story:**

1. **packages/client/src/App.tsx** - Replace test component with ChatInterface
2. **packages/client/package.json** - Add socket.io-client dependency
3. **.gitignore** - Ensure .env files excluded (if not already)

**No Files Deleted** - Story 3.2's test component code replaced, but component files retained

[Source: docs/architecture/unified-project-structure.md#Frontend Structure]

### Component Architecture

**Component Hierarchy:**

```
ChatInterface (Main Container)
â”œâ”€â”€ Header (Title + ThemeToggle placeholder)
â”œâ”€â”€ MessageList (Scrollable message display)
â”‚   â””â”€â”€ MessageItem (per message)
â”‚       â”œâ”€â”€ User message (right-aligned, primary bg)
â”‚       â””â”€â”€ Assistant message (left-aligned, muted bg)
â”œâ”€â”€ TypingIndicator (conditionally rendered)
â””â”€â”€ MessageInput (text input + send button)
```

**ChatInterface Component Structure:**

```tsx
// packages/client/src/components/chat/ChatInterface.tsx
import React from 'react';
import { MessageList } from './MessageList';
import { MessageInput } from './MessageInput';
import { TypingIndicator } from './TypingIndicator';
import { useSocket } from '../../hooks/useSocket';
import { useChat } from '../../hooks/useChat';
import type { ChatMessage } from '@bmad-app/shared';

export const ChatInterface: React.FC = () => {
  const { messages, addMessage, updateLastMessage } = useChat();
  const { sendMessage, isConnected, isStreaming } = useSocket({
    onChunk: (chunk, messageId) => {
      updateLastMessage(messageId, chunk);
    },
    onComplete: (messageId) => {
      // Finalize message (optional: update status to 'complete')
    },
    onError: (error) => {
      console.error('Socket error:', error);
    }
  });

  const handleSendMessage = (content: string) => {
    const messageId = crypto.randomUUID();
    addMessage({
      id: messageId,
      role: 'user',
      content,
      timestamp: Date.now(),
      status: 'complete'
    });
    sendMessage(content, messageId);
  };

  return (
    <div className="flex flex-col h-screen bg-background">
      <header className="flex items-center justify-between p-4 border-b">
        <h1 className="text-2xl font-bold">BMAD + Claude SDK</h1>
        {/* ThemeToggle placeholder - Story 3.4 */}
      </header>

      <MessageList messages={messages} />

      {isStreaming && <TypingIndicator />}

      <MessageInput
        onSend={handleSendMessage}
        disabled={!isConnected || isStreaming}
      />
    </div>
  );
};
```

**Key Implementation Details:**
- **Optimistic UI updates**: User message added to state immediately before server response
- **Streaming accumulation**: `updateLastMessage` appends chunks to existing assistant message
- **Connection status**: Input disabled when disconnected or streaming
- **Message ID generation**: crypto.randomUUID() for unique message tracking
- **Callback pattern**: useSocket accepts onChunk/onComplete/onError callbacks for event handling

[Source: docs/architecture/frontend-architecture.md#Component Architecture]

### State Management

**useChat Hook (Chat State):**

```typescript
// packages/client/src/hooks/useChat.ts
import { useState } from 'react';
import type { ChatMessage } from '@bmad-app/shared';

interface ChatState {
  messages: ChatMessage[];
  addMessage: (message: ChatMessage) => void;
  updateLastMessage: (messageId: string, chunk: string) => void;
  clearHistory: () => void;
}

export const useChat = (): ChatState => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);

  const addMessage = (message: ChatMessage) => {
    setMessages(prev => [...prev, message]);
  };

  const updateLastMessage = (messageId: string, chunk: string) => {
    setMessages(prev => {
      const lastMsg = prev[prev.length - 1];
      if (!lastMsg || lastMsg.role !== 'assistant') {
        // Create new assistant message
        return [...prev, {
          id: messageId,
          role: 'assistant',
          content: chunk,
          timestamp: Date.now(),
          status: 'sending'
        }];
      }
      // Append to existing assistant message
      return [...prev.slice(0, -1), {
        ...lastMsg,
        content: lastMsg.content + chunk
      }];
    });
  };

  const clearHistory = () => setMessages([]);

  return { messages, addMessage, updateLastMessage, clearHistory };
};
```

**Key Design Decisions:**
- **Immutable updates**: Spread operator pattern, no direct state mutation
- **Optimistic updates**: User messages added immediately (don't wait for server confirmation)
- **Streaming logic**: Check if last message is assistant before appending chunks (avoid creating multiple assistant messages)
- **Session scope**: Message history not persisted (cleared on page refresh per AC 11)

[Source: docs/architecture/frontend-architecture.md#State Management Architecture]

**useSocket Hook (Socket.io Client):**

```typescript
// packages/client/src/hooks/useSocket.ts
import { useEffect, useState, useCallback } from 'react';
import { createSocket } from '../lib/socket';
import type { Socket } from 'socket.io-client';

interface UseSocketOptions {
  onChunk: (chunk: string, messageId: string) => void;
  onComplete: (messageId: string) => void;
  onError: (error: { message: string; code?: string }) => void;
}

export const useSocket = (options: UseSocketOptions) => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isStreaming, setIsStreaming] = useState(false);

  useEffect(() => {
    const socketInstance = createSocket();
    setSocket(socketInstance);

    socketInstance.on('connect', () => setIsConnected(true));
    socketInstance.on('disconnect', () => setIsConnected(false));

    socketInstance.on('agent_response_chunk', (data) => {
      setIsStreaming(true);
      options.onChunk(data.chunk, data.messageId);
    });

    socketInstance.on('agent_response_complete', (data) => {
      setIsStreaming(false);
      options.onComplete(data.messageId);
    });

    socketInstance.on('error', (data) => {
      setIsStreaming(false);
      options.onError(data);
    });

    return () => {
      socketInstance.disconnect();
    };
  }, []);

  const sendMessage = useCallback((content: string, messageId: string) => {
    if (!socket) return;
    socket.emit('user_message', { content, messageId });
  }, [socket]);

  return { sendMessage, isConnected, isStreaming };
};
```

**Key Design Decisions:**
- **Lifecycle management**: Socket initialized in useEffect, cleanup on unmount
- **Connection state tracking**: isConnected and isStreaming states for UI feedback
- **Callback pattern**: Options object with event handlers for flexibility
- **useCallback optimization**: Prevents unnecessary re-renders when sendMessage callback changes

[Source: docs/architecture/frontend-architecture.md#Frontend Services Layer]

### Data Models

**ChatMessage Interface:**

```typescript
// packages/shared/src/types.ts
interface ChatMessage {
  id: string;                    // UUID or timestamp-based unique ID
  role: 'user' | 'assistant';    // Message sender
  content: string;               // Message text (markdown supported for agent)
  timestamp: number;             // Unix timestamp (Date.now())
  status: 'sending' | 'complete' | 'error'; // Delivery status
}
```

**Socket Event Types:**

```typescript
// Client â†’ Server
interface UserMessageEvent {
  content: string;
  messageId: string;
}

// Server â†’ Client (streaming chunks)
interface AgentResponseChunkEvent {
  chunk: string;
  messageId: string;
}

// Server â†’ Client (stream complete)
interface AgentResponseCompleteEvent {
  messageId: string;
}

// Server â†’ Client (errors)
interface ErrorEvent {
  message: string;
  code?: string;
}
```

**Rationale**: Shared types prevent client/server type mismatches, enable refactoring confidence, and provide IDE autocomplete for Socket.io event payloads.

[Source: docs/architecture/data-models.md#Framework Message Model, docs/architecture/data-models.md#Socket Event Model]

### Socket.io Integration

**Socket.io Client Setup:**

```typescript
// packages/client/src/lib/socket.ts
import { io, Socket } from 'socket.io-client';

const SOCKET_URL = import.meta.env.VITE_SOCKET_URL || 'http://localhost:3000';

export const createSocket = (): Socket => {
  const socket = io(SOCKET_URL, {
    autoConnect: true,
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionAttempts: 5
  });

  socket.on('connect', () => {
    console.log('âœ… Connected to server');
  });

  socket.on('disconnect', () => {
    console.log('âŒ Disconnected from server');
  });

  socket.on('connect_error', (error) => {
    console.error('Connection error:', error);
  });

  return socket;
};
```

**Configuration Details:**
- **autoConnect: true** - Connect immediately when created
- **reconnection: true** - Automatically attempt reconnection on disconnect
- **reconnectionDelay: 1000** - Wait 1 second before first reconnection attempt
- **reconnectionAttempts: 5** - Try up to 5 times before giving up
- **VITE_SOCKET_URL** - Environment variable for server URL (defaults to localhost:3000)

**Event Flow:**
1. User types message â†’ ChatInterface calls handleSendMessage
2. handleSendMessage creates message object â†’ adds to state â†’ calls sendMessage from useSocket
3. useSocket emits `user_message` event to server
4. Server processes message â†’ emits `agent_response_chunk` events
5. useSocket receives chunks â†’ calls onChunk callback â†’ updateLastMessage updates state
6. React re-renders MessageList â†’ new chunk appears in UI
7. Server emits `agent_response_complete` â†’ useSocket calls onComplete â†’ streaming stops

[Source: docs/architecture/frontend-architecture.md#Frontend Services Layer, docs/architecture/core-workflows.md#User Message â†’ Agent Response]

### Auto-Scroll Implementation

**MessageList Auto-Scroll Pattern:**

```tsx
// packages/client/src/components/chat/MessageList.tsx
import { useEffect, useRef } from 'react';
import { ScrollArea } from '@/components/ui/scroll-area';
import { MessageItem } from './MessageItem';
import type { ChatMessage } from '@bmad-app/shared';

export const MessageList: React.FC<{ messages: ChatMessage[] }> = ({ messages }) => {
  const scrollRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // Auto-scroll to bottom when new messages arrive
    if (scrollRef.current) {
      scrollRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages.length]);

  return (
    <ScrollArea className="flex-1 p-4">
      <div className="flex flex-col gap-4">
        {messages.length === 0 && (
          <div className="text-center text-muted-foreground">
            Start a conversation...
          </div>
        )}
        {messages.map(msg => (
          <MessageItem key={msg.id} message={msg} />
        ))}
        <div ref={scrollRef} />
      </div>
    </ScrollArea>
  );
};
```

**Key Implementation Details:**
- **useRef for scroll target**: Create invisible div at bottom of message list
- **useEffect dependency**: Trigger scroll when messages.length changes
- **Smooth behavior**: { behavior: 'smooth' } provides animated scrolling
- **Empty state**: Display welcome message when no messages exist

[Source: docs/architecture/frontend-architecture.md#Component Architecture]

### Keyboard Shortcuts

**MessageInput Enter/Shift+Enter Handling:**

```tsx
// packages/client/src/components/chat/MessageInput.tsx
const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault(); // Prevent newline
    handleSend();
  }
  // Shift+Enter: Allow default behavior (newline)
};

return (
  <textarea
    value={input}
    onChange={(e) => setInput(e.target.value)}
    onKeyDown={handleKeyDown}
    placeholder="Type a message..."
    disabled={disabled}
    className="flex-1 resize-none"
    rows={1}
  />
);
```

**Rationale**: Industry-standard chat UX - Enter sends message, Shift+Enter adds newline for multi-line messages.

[Source: docs/prd/epic-3-react-frontend-with-chat-interface.md#Story 3.3 AC 12]

### Coding Standards

**Critical Rules for This Story:**
- âœ… **Type Sharing**: All types defined in `packages/shared/src/types.ts` and imported from there (NEVER duplicate)
- âœ… **Socket Event Names**: Use exact event names from shared types (`user_message`, `agent_response_chunk`, etc.) - NEVER invent new names
- âœ… **State Immutability**: NEVER mutate React state directly - always use setState with new objects/arrays
- âœ… **Async/Await**: Use async/await for all asynchronous operations (Socket.io event handlers)
- âœ… **Logging Pattern**: Use console.log with clear prefixes for development (e.g., "âœ… Connected to server") - future: migrate to logger utility

**Naming Conventions:**

| Element | Convention | Example |
|---------|-----------|---------|
| Components | PascalCase | ChatInterface.tsx, MessageList.tsx |
| Hooks | camelCase with 'use' prefix | useSocket.ts, useChat.ts |
| Files (general) | kebab-case | socket.ts, message-item.tsx |
| Socket Events | snake_case | user_message, agent_response_chunk |
| Functions | camelCase | handleSendMessage, updateLastMessage |

[Source: docs/architecture/coding-standards.md#Critical Fullstack Rules, docs/architecture/coding-standards.md#Naming Conventions]

### Testing

**Testing Strategy for This Story:**
- **Manual Testing Only** - No automated test framework for MVP
- Verification steps (AC 1-12):
  1. **Socket Connection**: Open browser dev tools â†’ verify "Connected to server" message in console
  2. **Send User Message**: Type message, click Send â†’ verify message appears right-aligned with primary bg
  3. **Socket Event Emission**: Check server console â†’ verify `user_message` event logged
  4. **Agent Response Streaming**: Type message â†’ verify agent chunks appear left-aligned in real-time
  5. **Typing Indicator**: Verify animated dots appear during streaming
  6. **Message Accumulation**: Send multiple messages â†’ verify all messages visible in scrollable list
  7. **Auto-Scroll**: Send message â†’ verify list auto-scrolls to bottom smoothly
  8. **Enter Key**: Press Enter â†’ verify message sends (without Shift key)
  9. **Shift+Enter**: Press Shift+Enter â†’ verify newline added (message not sent)
  10. **Connection Status**: Stop server â†’ verify input disabled with "Disconnected" state
  11. **Reconnection**: Restart server â†’ verify auto-reconnect and input re-enabled
  12. **Production Build**: Build client, start server, access `http://localhost:3000/chat` â†’ verify all features work
  13. **Console Check**: Verify no errors or warnings in browser dev tools

**Future Test Organization:**
- Component tests: Test ChatInterface with mocked useSocket hook
- Hook tests: Test useChat state updates, useSocket event handlers
- Integration tests: Test complete message flow with Socket.io test server
- [Source: docs/architecture/testing-strategy.md#Frontend Tests]

**No test files created in this story** - Manual browser testing sufficient for MVP chat UI verification

### Performance Considerations

**Rendering Optimization:**
- **Message list virtualization**: Not implemented for MVP (simple list rendering sufficient)
- **Future enhancement**: Use react-virtual or react-window for 1000+ messages (post-MVP)
- **Current performance**: Acceptable for typical conversation length (< 100 messages)

**State Update Optimization:**
- **Immutable updates**: Spread operator creates new arrays, React detects changes correctly
- **useCallback**: Prevents unnecessary re-renders when sendMessage callback passed as prop
- **Message key**: msg.id ensures React reconciliation efficiency (no array index keys)

**Socket.io Optimization:**
- **Auto-reconnection**: Prevents manual reconnection UI (better UX)
- **Single socket instance**: Created once in useEffect, reused across component lifecycle
- **Event cleanup**: Socket disconnected on component unmount (no memory leaks)

[Source: docs/architecture/security-and-performance.md#Performance Optimization]

### Security Considerations

**Client-Side Security:**
- **No XSS risk**: Message content rendered as plain text (markdown rendering post-MVP)
- **Socket URL validation**: VITE_SOCKET_URL from environment variable (no hardcoded localhost in production)
- **Future consideration**: Sanitize markdown rendering when implemented (use DOMPurify)

**Socket.io Security:**
- **No authentication**: MVP localhost-only (no auth required)
- **Future consideration**: Add Socket.io authentication middleware for multi-user deployment
- **CORS**: Server must configure CORS to allow Vite dev server (localhost:5173)

[Source: docs/architecture/security-and-performance.md#Security Requirements]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-16 | 1.0 | Initial story creation from PRD Epic 3 Story 3.3 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

(To be populated by Dev Agent)

### Debug Log References

(To be populated by Dev Agent)

### Completion Notes List

(To be populated by Dev Agent)

### File List

(To be populated by Dev Agent)

## QA Results

(To be populated by QA Agent)
