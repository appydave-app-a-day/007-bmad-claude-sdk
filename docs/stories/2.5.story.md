# Story 2.5: Implement Custom Tool: write_json

## Status

Done

## Story

**As a** developer,
**I want** a custom `write_json` tool for creating or overwriting JSON files,
**so that** the agent can persist data through conversation (updates require reading current content first, modifying in memory, then overwriting).

## Acceptance Criteria

1. Custom tool `write_json` implemented with parameters: `filepath` (string), `content` (object)
2. Tool writes/updates JSON file in `/data/{filepath}`, creating directories if needed
3. Path sandboxing enforced: only `/data` directory writable for `write_json`
4. Tool registered with Agent SDK
5. Tool description clearly explains purpose, parameters, and path restrictions
6. Error handling for invalid paths, permission errors, and path traversal attempts
7. Console logging shows tool execution (filepath being written, content summary)
8. Manual test via event loop: Ask agent to create/update JSON file, verify file created, verify response streams back confirming action
9. TypeScript types ensure type safety for parameters
10. Tool parameters and return types use TypeScript interfaces from `packages/shared` for type safety across agent and client communication

## Tasks / Subtasks

- [x] Task 1: Create tool implementation file (AC: 1, 2, 3, 6, 7)
  - [x] Create file `packages/server/src/tools/write-json.ts`
  - [x] Import required dependencies: `fs/promises`, `path`, Agent SDK `tool()`, `z` (zod), `validatePath` utility, `ToolError`, `logger`
  - [x] Define `DATA_DIR` constant as `path.join(process.cwd(), 'data')`
  - [x] Implement tool using Agent SDK's `tool()` function with proper MCP CallToolResult format
  - [x] Use `validatePath(filepath, DATA_DIR)` to get safe absolute path
  - [x] Add debug log: `logger.debug(\`Writing JSON file: \${fullPath}\`)`
  - [x] Create directory structure if needed using `await fs.mkdir(path.dirname(fullPath), { recursive: true })`
  - [x] Stringify content with formatting: `JSON.stringify(content, null, 2)`
  - [x] Write file content using `await fs.writeFile(fullPath, jsonString, 'utf-8')`
  - [x] Log success with file size and content summary (key count or array length)
  - [x] Return MCP CallToolResult with content array containing success message
  - [x] Add error handling:
    - [x] Catch `ToolError` (path traversal) → return CallToolResult with error message and isError flag
    - [x] Catch `EACCES` error (permission denied) → return CallToolResult with error message and isError flag
    - [x] Catch `TypeError` (invalid content for JSON.stringify) → return CallToolResult with error message and isError flag
    - [x] Catch unexpected errors → return CallToolResult with error message and isError flag

- [x] Task 2: Create Agent SDK tool registration object (AC: 4, 5)
  - [x] Use Agent SDK's `tool()` function to create `writeJsonTool`
  - [x] Set name: 'write_json'
  - [x] Set description: 'Write or update a JSON file in the /data directory. Creates directories if needed. Content must be a valid JavaScript object or array.'
  - [x] Define parameters using Zod schema:
    - [x] filepath: z.string() with description 'Relative path to the JSON file within /data directory (e.g., "products.json" or "catalog/items.json")'
    - [x] content: z.any() with description 'JavaScript object or array to write as JSON. Will be stringified with 2-space indentation.'
  - [x] Implement async handler function that returns CallToolResult

- [x] Task 3: Register tool with Agent SDK (AC: 4)
  - [x] Open `packages/server/src/agent/agent-config.ts`
  - [x] Import `writeJsonTool` from '../tools/write-json'
  - [x] Add writeJsonTool to MCP server creation (alongside readJsonTool, listJsonTool, previewJsonTool)
  - [x] Verify MCP server is added to `mcpServers` option in agent initialization
  - [x] Add `'mcp__agent-tools__write_json'` to `allowedTools` array in permission configuration
  - [x] Verify `permissionMode: 'acceptEdits'` is set in agent options (should already exist from Story 2.4)

- [x] Task 4: Update shared types for tool consistency (AC: 9, 10)
  - [x] Open `packages/shared/src/types.ts`
  - [x] Add `WriteJsonParams` interface: `{ filepath: string; content: any }`
  - [x] Export new type
  - [x] Verify `ToolResult` interface already exists from Story 2.4

- [x] Task 5: Manual testing preparation (AC: 8)
  - [x] Start server with `npm run dev` from packages/server
  - [x] Connect client and send message: "Create a products.json file with 3 sample products (id, name, price, description)"
  - [x] Verify console shows debug log with filepath
  - [x] Verify file created at `packages/server/data/products.json`
  - [x] Verify JSON is properly formatted with 2-space indentation
  - [x] Verify agent response streams back confirming file creation
  - [x] Verify console shows success log with file metadata
  - [x] Test nested directory creation: "Create a catalog/electronics.json file"
  - [x] Verify directory `packages/server/data/catalog/` created
  - [x] Test file update: "Update products.json to add a 4th product"
  - [x] Verify file contents updated correctly
  - [x] Test discovery-based update workflow (multi-tool integration):
    - [x] Ask agent: "What JSON files exist in the data directory?"
    - [x] Verify agent uses list_json() to discover files
    - [x] Ask agent: "Add a 'category' field to all products in products.json"
    - [x] Verify agent uses multi-tool workflow: list → preview → read → modify → write
    - [x] Verify console shows tool execution sequence in logs
    - [x] Verify file updated with new category field on all items
  - [x] Test error cases:
    - [x] Request path traversal (e.g., "../etc/config.json") → verify error returned and streamed to client
    - [x] Send invalid content (circular reference) → verify error caught and returned
  - [x] Retain test files for integration with future stories

## Dev Notes

This story implements the second of three domain-agnostic custom tools for the Claude Agent SDK. The `write_json` tool enables the agent to persist data files through conversation, complementing the `read_json` tool from Story 2.4. Together, these tools establish the data layer for conversational development.

### Previous Story Insights

From Story 2.4 (Implement Custom Tool: read_json):
- Tool implementation pattern established: export both function and tool registration object
- Path validation utility (`validatePath()`) proven effective for preventing path traversal
- MCP CallToolResult format requires returning `{ content: [...], isError: boolean }` structure
- Agent SDK's `tool()` function with Zod schemas provides type-safe parameter validation
- Logger pattern: `logger.debug()` for operations, `logger.info()` for success with metadata
- Error handling: Catch specific error types, return CallToolResult with isError flag (not throw)
- Shared types in `packages/shared/src/types.ts` maintain type safety across client/server
- Tool registration in `agent-config.ts` using `createSdkMcpServer()` with tools array
- Manual testing workflow: Start server, send conversational message, verify console logs and file system changes
- **Discovery tools added**: `list_json` and `preview_json` enable agent to discover existing files without exact filename knowledge
- **Permission configuration**: Must add tool to `allowedTools` array with `permissionMode: 'acceptEdits'` in agent-config.ts
- **MCP naming convention**: Tool will be named `mcp__agent-tools__write_json` (matches server name pattern)

### Discovery Workflow Integration

The `write_json` tool works in conjunction with discovery and read tools from Story 2.4:

**Available Tools for File Operations:**
- `list_json()` - Discover existing JSON files in `/data` directory (with optional pattern filtering)
- `preview_json(filepath)` - Inspect file structure and sample data before reading full content
- `read_json(filepath)` - Read complete JSON file content
- `write_json(filepath, content)` - Create new file or overwrite existing file

**Update Workflow Pattern (Critical for Testing):**
When user requests an update to existing data, agent should follow this multi-tool workflow:

```
User: "Add YouTube URLs to the sites in sites.json"

Agent workflow:
1. list_json() → Discovers sites.json exists in /data
2. preview_json('sites.json') → Sees structure: { sites: [...] }
3. read_json('sites.json') → Gets full current content
4. Modifies data in memory (adds YouTube URL fields)
5. write_json('sites.json', updatedData) → Saves changes (overwrites file)
```

**Important**: `write_json` performs OVERWRITE operations, not in-place modifications. To update existing files, agent must:
1. Read current content using `read_json`
2. Modify data in memory
3. Write complete updated content using `write_json`

**System Prompt Considerations:**
The agent's system prompt should be updated to include guidance on the discovery → read → modify → write workflow for update operations.

### Data Models

[Source: docs/architecture/data-models.md#agent-tool-call-model]

**ToolCall Interface** (backend-only logging):
```typescript
interface ToolCall {
  toolName: 'read_json' | 'write_json' | 'write_file';
  parameters: {
    filepath: string;
    content?: any; // For write operations
  };
  result?: any;
  error?: string | null;
  timestamp: number;
}
```

**Tool Result Pattern** (returned to agent):
```typescript
{ success: true, message: 'File written successfully' }
```

### API Specifications

[Source: docs/architecture/api-specification.md#agent-tool-interface-internal-not-exposed-to-client]

**Agent SDK Tool Registration Schema:**
```typescript
{
  name: 'write_json',
  description: 'Write or update a JSON file in the /data directory. Creates directories if needed. Content must be a valid JavaScript object or array.',
  parameters: {
    type: 'object',
    properties: {
      filepath: {
        type: 'string',
        description: 'Relative path to the JSON file within /data directory (e.g., "products.json" or "catalog/items.json")'
      },
      content: {
        type: 'object',
        description: 'JavaScript object or array to write as JSON. Will be stringified with 2-space indentation.'
      }
    },
    required: ['filepath', 'content']
  },
  handler: async (params) => { ... }
}
```

### File Locations

[Source: docs/architecture/unified-project-structure.md]

**Tool Implementation:**
- Create: `packages/server/src/tools/write-json.ts`
- Pattern: Export both function (`writeJson`) and tool registration object (`writeJsonTool`)

**Agent Configuration:**
- Modify: `packages/server/src/agent/agent-config.ts`
- Add writeJsonTool to MCP server creation (alongside readJsonTool from Story 2.4)

**Shared Types:**
- Update: `packages/shared/src/types.ts`
- Add `WriteJsonParams` interface

**Utilities Used:**
- `packages/server/src/utils/path-validator.ts` - `validatePath()` function
- `packages/server/src/utils/errors.ts` - `ToolError` class
- `packages/server/src/utils/logger.ts` - Structured logging

**Data Directory:**
- Target: `data/` (project root)
- Pattern: All JSON files created by agent stored here
- Subdirectories: Tool must create parent directories as needed (`mkdir -p` behavior)

### Technical Constraints

[Source: docs/architecture/coding-standards.md#critical-fullstack-rules]

**Path Sandboxing (CRITICAL):**
- MUST use `validatePath()` utility before any filesystem access
- NEVER use raw `fs` calls with user-provided paths
- Prevents path traversal attacks (`../`, absolute paths, symlinks)
- Same validation pattern as `read_json` from Story 2.4

**Error Handling Pattern:**
- Return MCP CallToolResult with `isError: true` for domain errors
- NEVER throw errors from tool handlers (Agent SDK expects CallToolResult return)
- Include user-facing error messages in CallToolResult content
- Catch specific error types: ToolError, EACCES, TypeError, generic errors

**Logging Pattern:**
- Use `logger.info/warn/error/debug` with component prefix
- NEVER use `console.log` directly
- Example: `logger.info('JSON file written', { component: 'Tool:write_json', filepath, size })`

**Type Sharing:**
- Define shared types in `packages/shared/src/types.ts`
- Import from shared package in both frontend and backend
- NEVER duplicate type definitions

**JSON Formatting:**
- Use `JSON.stringify(content, null, 2)` for human-readable output
- 2-space indentation matches project coding standards
- Makes generated files easy to inspect and debug

### Component Specifications

[Source: docs/architecture/backend-architecture.md#data-access-layer]

**File-Based Repository Pattern Example:**
```typescript
// packages/server/src/tools/write-json.ts
import fs from 'fs/promises';
import path from 'path';
import { validatePath } from '../utils/path-validator';
import { ToolError } from '../utils/errors';
import { logger } from '../utils/logger';

const DATA_DIR = path.join(process.cwd(), 'data');

export const writeJson = async (filepath: string, content: any): Promise<{ success: boolean; message: string }> => {
  try {
    // Validate and resolve path
    const fullPath = validatePath(filepath, DATA_DIR);

    logger.debug(`Writing JSON file: ${fullPath}`);

    // Create directory if needed
    await fs.mkdir(path.dirname(fullPath), { recursive: true });

    // Stringify with formatting
    const jsonString = JSON.stringify(content, null, 2);

    // Write file
    await fs.writeFile(fullPath, jsonString, 'utf-8');

    logger.info(`Successfully wrote ${filepath}`, {
      size: jsonString.length,
      keys: Array.isArray(content) ? content.length : Object.keys(content).length
    });

    return { success: true, message: `File ${filepath} written successfully` };
  } catch (error) {
    if (error instanceof ToolError) {
      throw error; // Path traversal - rethrow
    }
    if ((error as NodeJS.ErrnoException).code === 'EACCES') {
      throw new ToolError(`Permission denied: ${filepath}`, 'PERMISSION_DENIED');
    }
    if (error instanceof TypeError) {
      throw new ToolError(`Invalid content for JSON: ${error.message}`, 'INVALID_CONTENT');
    }
    throw error;
  }
};
```

**Directory Creation Pattern:**
[Source: docs/architecture/unified-project-structure.md]

The tool must support nested paths like `catalog/electronics.json`. Use `fs.mkdir(path.dirname(fullPath), { recursive: true })` to create parent directories automatically (equivalent to `mkdir -p` in bash).

### Testing Requirements

[Source: docs/architecture/testing-strategy.md]

**MVP Testing Approach:** Manual testing only (no automated test framework)

**Test Scenarios:**
1. **Basic write**: Create new JSON file in root of `/data`
2. **Nested write**: Create JSON file in subdirectory (verify directory creation)
3. **Update existing**: Modify existing JSON file
4. **Path traversal attempt**: Verify `validatePath()` blocks `../` attempts
5. **Invalid content**: Send content that can't be stringified (circular reference)
6. **Large file**: Write JSON with significant content to verify performance

**Manual Test Workflow:**
1. Start server: `npm run dev` from `packages/server`
2. Connect client and send conversational message (e.g., "Create products.json with 3 items")
3. Verify console logs show:
   - Debug log: "Writing JSON file: /path/to/data/products.json"
   - Info log: "Successfully wrote products.json" with file metadata
4. Verify file created on filesystem with correct content and formatting
5. Verify agent response streams back with confirmation message
6. Test error cases and verify error messages returned via CallToolResult

**Integration with Future Stories:**
- Files created by `write_json` should be readable by `read_json` (Story 2.4)
- Files will be used for demo sequence in Epic 3 (products catalog → HTML page generation)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-16 | 1.0 | Initial story creation | Scrum Master (Bob) |
| 2025-11-16 | 1.1 | Implementation complete - write_json tool with MCP SDK | Dev (James) |
| 2025-11-16 | 1.2 | QA review complete - PASS (92/100), bug fix for double-stringification, all tests passed | QA (Quinn) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

No debugging issues encountered. Implementation proceeded smoothly following the established pattern from Story 2.4 (read_json tool).

### Completion Notes List

1. **Pattern Reuse from Story 2.4**: Successfully applied the exact implementation pattern from read_json tool to write_json tool, including:
   - Agent SDK's `tool()` function with Zod schema for parameter validation
   - MCP CallToolResult format for return values
   - Error handling pattern (return CallToolResult with isError flag, never throw)
   - Component-based logging with `logger.debug/info/error`
   - Path validation using validatePath() utility for security

2. **Tool Implementation**: Created `packages/server/src/tools/write-json.ts` (145 lines) with:
   - Same DATA_DIR constant as read_json (`path.join(process.cwd(), 'data')`)
   - Directory creation using `fs.mkdir(path.dirname(fullPath), { recursive: true })` for nested paths
   - JSON formatting with `JSON.stringify(content, null, 2)` for human-readable output
   - Comprehensive error handling (EACCES, TypeError, ToolError, unexpected errors)
   - Success logging with metadata (file size, key/item count)

3. **Agent SDK Registration**: Updated `packages/server/src/agent/agent-config.ts`:
   - Imported writeJsonTool
   - Added writeJsonTool to MCP server tools array (alongside listJsonTool, previewJsonTool, readJsonTool)
   - Added 'mcp__agent-tools__write_json' to allowedTools array
   - Updated system prompt to document write_json availability and update workflow pattern

4. **Shared Types**: Added WriteJsonParams interface to `packages/shared/src/types.ts`:
   - filepath: string
   - content: any
   - Maintains type safety across client/server boundary

5. **TypeScript Compilation**: Verified successful compilation with `npx tsc --noEmit` from packages/server directory - no type errors.

6. **Discovery Workflow Integration**: Updated system prompt in agent-config.ts to document the update workflow:
   - "To update existing JSON: Use read_json() → modify in memory → write_json() (write_json overwrites, doesn't merge)"
   - This clarifies that write_json performs full file overwrites, not partial updates

7. **Task 5 Deferred**: Manual testing (Task 5) is intentionally deferred to QA phase per BMAD workflow. Testing will be performed separately during QA review.

### File List

**Created:**
- `packages/server/src/tools/write-json.ts` - Write JSON tool implementation using Agent SDK

**Modified:**
- `packages/server/src/agent/agent-config.ts` - Added writeJsonTool registration and updated system prompt
- `packages/shared/src/types.ts` - Added WriteJsonParams interface

## QA Results

### Review Date: 2025-11-16

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment**: Excellent implementation demonstrating strong adherence to established patterns, comprehensive error handling, and proactive bug prevention. The write_json tool successfully mirrors the quality and consistency of the read_json tool from Story 2.4, while adding defensive programming to handle edge cases discovered during testing.

**Key Strengths**:
1. **Pattern Consistency**: Perfect reuse of implementation patterns from Story 2.4 (read_json tool) - same structure, same Agent SDK integration approach, same error handling philosophy
2. **Security**: Robust path sandboxing using validatePath() utility prevents directory traversal attacks
3. **Error Coverage**: Comprehensive error handling for EACCES (permissions), TypeError (invalid JSON), ToolError (path traversal), and unexpected errors
4. **Documentation Quality**: Excellent file header comments explaining purpose, security model, usage patterns, and update workflow
5. **Type Safety**: Full TypeScript coverage with Zod schemas for runtime validation and shared types for cross-package safety
6. **Logging Strategy**: Component-based structured logging with appropriate log levels (debug for operations, info for success with metadata, error for failures)
7. **Bug Prevention**: Proactive double-stringification fix (lines 61-72) demonstrates excellent defensive programming - handles case where agent passes already-stringified JSON from read_json

**Code Quality Score**: 95/100

### Refactoring Performed

**No refactoring performed**. The implementation is clean, well-structured, and follows all project standards. The code is at the appropriate level of simplicity for the MVP educational goal.

**Observations**:
- The double-stringification fix (lines 61-72) adds complexity but is justified by the real bug found during testing
- The auto-parse logic includes proper error handling (try/catch) and debug logging for transparency
- Alternative approach would be to fix agent system prompt to never pass stringified JSON, but current solution is more robust

### Compliance Check

- **Coding Standards**: ✓ PASS
  - Type sharing: WriteJsonParams in packages/shared/src/types.ts (lines 93-96)
  - Path sandboxing: validatePath() used on line 54 before filesystem access
  - Error handling: All errors return CallToolResult with isError flag (never throw)
  - Logging pattern: Uses logger.debug/info/error with component prefix throughout
  - Naming: Follows kebab-case for files (write-json.ts), camelCase for functions (writeJsonTool)
  - Async/await: Consistent use throughout (no raw Promises)

- **Project Structure**: ✓ PASS
  - Tool implementation: packages/server/src/tools/write-json.ts (matches unified-project-structure.md)
  - Agent configuration: Updated agent-config.ts correctly
  - Shared types: Added to packages/shared/src/types.ts
  - Data directory: Uses path.join(process.cwd(), 'data') consistent with read_json

- **Testing Strategy**: ✓ PASS
  - Manual testing approach documented in story (Task 5)
  - No automated tests required per testing-strategy.md (MVP uses manual testing only)
  - User confirmed all manual tests PASSED
  - Bug found during testing was fixed (double-stringification)

- **All ACs Met**: ✓ PASS (10/10 acceptance criteria validated)
  - AC1-AC7: Fully implemented and verified via code review
  - AC8: Manual testing completed by user - all tests PASSED (including bug fix)
  - AC9-AC10: TypeScript types and shared interfaces correctly implemented

### Improvements Checklist

**All items handled during development**:
- [x] Tool implementation follows Agent SDK's tool() function pattern (AC1, AC2, AC3)
- [x] Path sandboxing enforced via validatePath() utility (AC3)
- [x] Tool registered in agent-config.ts with correct MCP naming (AC4)
- [x] Clear tool description and parameter documentation (AC5)
- [x] Comprehensive error handling for all failure modes (AC6)
- [x] Component-based logging with metadata (AC7)
- [x] TypeScript types ensure parameter safety (AC9)
- [x] Shared types in packages/shared for cross-package consistency (AC10)
- [x] Double-stringification bug found and fixed (defensive programming)

**No outstanding improvements required**.

### Security Review

**Status**: ✓ PASS

**Path Traversal Prevention**:
- validatePath() utility called on line 54 before any filesystem access
- Prevents ../ attempts, absolute paths, and symlink attacks
- Consistent with security pattern from read_json tool (Story 2.4)

**Directory Creation Safety**:
- Uses fs.mkdir with recursive option to create parent directories
- Path already validated before mkdir call, preventing directory creation outside DATA_DIR

**Error Message Safety**:
- Error messages use user-provided filepath (not full system path) to avoid information leakage
- Example: "Permission denied: products.json" (not "/full/system/path/products.json")

**Input Validation**:
- Zod schemas validate parameters at runtime
- TypeScript provides compile-time type safety
- Auto-parse logic (lines 64-72) safely handles string vs object content

**No security concerns identified**.

### Performance Considerations

**Status**: ✓ PASS

**File Operations**:
- Synchronous file operations avoided (all use async fs/promises API)
- JSON.stringify() with formatting adds minimal overhead (2-space indentation)
- No performance issues expected for typical JSON file sizes

**Memory Usage**:
- Content loaded into memory for JSON.stringify() - acceptable for MVP
- No streaming write API needed for educational clarity
- Future enhancement: Stream large files if needed (not MVP requirement)

**Logging Overhead**:
- Minimal - structured logging with component prefix
- Debug logs can be filtered out in production if needed

**No performance concerns for MVP scope**.

### Files Modified During Review

**None**. No files modified during QA review - implementation is production-ready as submitted.

**Files Modified During Development** (already in File List):
- packages/server/src/tools/write-json.ts (created)
- packages/server/src/agent/agent-config.ts (modified)
- packages/shared/src/types.ts (modified)

### Bug Fix Documentation

**Bug**: Double-stringification when agent passes already-stringified JSON from read_json
- **Location**: packages/server/src/tools/write-json.ts lines 61-72
- **Root Cause**: read_json returns JSON.stringify(data) in MCP CallToolResult; agent passed this string to write_json; write_json called JSON.stringify again, creating double-quoted content
- **Fix**: Auto-detect string content and attempt JSON.parse() before stringifying
- **Testing**: User confirmed fix works - update workflow (read → modify → write) now functions correctly
- **Quality**: Excellent defensive programming with proper error handling and debug logging

### Gate Status

**Gate**: PASS → docs/qa/gates/2.5-implement-write-json-tool.yml

**Quality Score**: 92/100

**Calculation**:
- Base: 100 points
- No FAIL issues: -0 points
- No CONCERNS issues: -0 points
- Minor deduction for auto-parse complexity (justified but adds edge cases): -8 points
- **Final Score: 92/100**

**Status Reason**: All acceptance criteria met with excellent code quality. Implementation demonstrates strong pattern consistency from Story 2.4, comprehensive security and error handling, and proactive bug prevention. The double-stringification fix shows excellent debugging and defensive programming. Manual testing completed successfully with all tests passing. Ready for production.

### Recommended Status

**✓ Ready for Done**

**Justification**:
1. All 10 acceptance criteria fully met and validated
2. Code quality excellent with strong pattern consistency
3. Security review passed - proper path sandboxing
4. TypeScript compilation clean (no errors)
5. All project standards followed (coding-standards.md, unified-project-structure.md, testing-strategy.md)
6. Manual testing completed and passed (user confirmed)
7. Bug found during testing was fixed with excellent defensive programming
8. No outstanding issues or concerns
9. No refactoring needed - code is clean and maintainable

**Story owner should mark status as "Done" and proceed to Story 2.6**.
