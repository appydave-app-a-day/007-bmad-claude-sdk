# Story 2.3 - Story Acceptance Test (SAT) Guide

## Story Overview

**Title**: Add Response Streaming to Event Loop

**Total Acceptance Criteria**: 10

**Story Goal**: Enable real-time streaming of agent responses with progressive display in the client, replacing synchronous response collection from Story 2.2.

**Status**: Implementation Complete - Ready for QA Review

---

## Test Environment Setup

### Prerequisites

1. **Verify Story 2.2 Complete**: Ensure basic event loop from Story 2.2 is working
2. **Node Version**: Node.js 18+ installed
3. **Dependencies Installed**: Run `npm install` in project root
4. **TypeScript Build**: Verify `npm run build` completes without errors
5. **Server Running**: Start development server with `npm run dev`

### Test Environment Configuration

```bash
# From project root: /Users/davidcruwys/dev/ad/appydave-app-a-day/007-bmad-claude-sdk

# Step 1: Install dependencies
npm install

# Step 2: Build TypeScript
npm run build

# Step 3: Start development server
npm run dev

# Expected output:
# Server listening on port 3000
# Socket.io server initialized
# Agent SDK initialized with streaming enabled
```

### Files Modified in This Story

1. `packages/server/src/agent/event-loop.ts` - Streaming event loop
2. `packages/shared/src/types.ts` - Streaming event types
3. `packages/server/src/server.ts` - Socket.io streaming integration
4. `packages/client/index.html` - Client streaming event handlers

---

## Human Tests (Visual Verification in Browser)

### Test 1: Start Server and Verify Streaming Infrastructure Loads

**Acceptance Criteria**: AC1, AC2, AC10

**Steps**:
1. Open terminal and run: `npm run dev`
2. Open browser to: http://localhost:3000/chat
3. Open browser DevTools (F12) → Console tab
4. Open server terminal side-by-side with browser

**Expected Results**:
- ✅ Server logs show: "Server listening on port 3000"
- ✅ Server logs show: "Socket.io server initialized"
- ✅ Browser console shows: "Connected to Socket.io server"
- ✅ Chat interface loads with input field and send button
- ✅ No errors in browser console or server terminal

**Actual Results**:
```
(Fill in during testing)

Pass: [ ] / Fail: [ ]
```

---

### Test 2: Send Message and Verify Progressive Response Display (Word-by-Word)

**Acceptance Criteria**: AC3, AC5, AC8

**Steps**:
1. In chat interface, type: "Count to 5"
2. Click "Send" button
3. Watch the assistant message area in the chat interface
4. Observe whether response appears all at once or progressively

**Expected Results**:
- ✅ Response appears progressively (not all at once)
- ✅ You should see words/numbers appearing one by one or in chunks: "1" → "2" → "3" → "4" → "5"
- ✅ NOT: Response appears complete immediately
- ✅ Input field disabled during response (re-enabled after completion)

**Actual Results**:
```
(Describe what you observed - did it stream progressively?)

Pass: [ ] / Fail: [ ]
```

---

### Test 3: Verify Server Console Shows Streaming Lifecycle Logs

**Acceptance Criteria**: AC7

**Steps**:
1. Clear server terminal logs (or note the current line)
2. Send message: "Tell me a story about a robot learning to paint"
3. Watch server terminal output as streaming occurs

**Expected Results**:
```
✅ Server logs show (in order):
[INFO] Streaming started { component: 'AgentEventLoop', messageId: 'msg-...' }
[INFO] Chunk 0 received { component: 'AgentEventLoop', messageId: 'msg-...', chunkLength: ... }
[INFO] Chunk 1 received { component: 'AgentEventLoop', messageId: 'msg-...', chunkLength: ... }
[INFO] Chunk 2 received { component: 'AgentEventLoop', messageId: 'msg-...', chunkLength: ... }
... (multiple chunk logs)
[INFO] Streaming complete { component: 'AgentEventLoop', messageId: 'msg-...', totalChunks: ... }
```

**Actual Results**:
```
(Copy actual server logs here)

Pass: [ ] / Fail: [ ]
```

---

### Test 4: Verify Browser Console Shows Chunk Reception Logs

**Acceptance Criteria**: AC5

**Steps**:
1. Clear browser console (right-click → Clear console)
2. Send message: "Tell me a story about a robot"
3. Watch browser console output as chunks arrive

**Expected Results**:
```
✅ Browser console shows (in order):
Received chunk: 0 <length>
Received chunk: 1 <length>
Received chunk: 2 <length>
... (multiple chunk logs)
Streaming complete for: msg-...
```

**Actual Results**:
```
(Copy actual browser console logs here)

Pass: [ ] / Fail: [ ]
```

---

### Test 5: Verify Message Completion (Input Re-Enabled, Form Cleared)

**Acceptance Criteria**: AC4, AC6

**Steps**:
1. Send message: "Count to 10"
2. Observe input field during streaming (should be disabled)
3. Watch for completion signal
4. Check input field state after streaming finishes

**Expected Results**:
- ✅ During streaming: Input field disabled, send button disabled
- ✅ During streaming: Loading indicator visible (if implemented)
- ✅ After `agent_response_complete` event:
  - Input field re-enabled
  - Send button re-enabled
  - Input field cleared (ready for next message)
  - Loading indicator hidden

**Actual Results**:
```
(Describe input field behavior during and after streaming)

Pass: [ ] / Fail: [ ]
```

---

### Test 6: Test Multiple Rapid Messages (Queue Handling)

**Acceptance Criteria**: AC1, AC3, AC4, AC5

**Steps**:
1. Send message: "Count to 3"
2. Immediately send another message: "Count to 5"
3. Immediately send another message: "Count to 7"
4. Watch both server logs and browser display

**Expected Results**:
- ✅ All three messages processed in order (no cross-contamination)
- ✅ Each message has its own `messageId` in logs
- ✅ Streaming chunks for message 1 complete before message 2 starts
- ✅ Browser shows three separate assistant responses
- ✅ No chunks from message 2 appear in message 1's response area

**Actual Results**:
```
(Describe message queue behavior - did they process correctly?)

Pass: [ ] / Fail: [ ]
```

---

### Test 7: Test Error Handling (Network Interruption Simulation)

**Acceptance Criteria**: AC9

**Steps**:
1. Send message: "Tell me a detailed story about a robot learning to paint"
2. While streaming is in progress, open browser DevTools → Network tab
3. Throttle network to "Offline" or click "Disable cache" and refresh
4. Observe error handling

**Alternative Method** (if DevTools method doesn't work):
1. Send message to start streaming
2. Quickly restart server (Ctrl+C → npm run dev)
3. Observe partial message in browser

**Expected Results**:
- ✅ Partial message visible in chat (shows chunks received so far)
- ✅ Browser console shows error: "Socket.io error: ..."
- ✅ Partial message marked with error status (visual indicator if implemented)
- ✅ Server logs show streaming error (if server-side interruption)
- ✅ Input field re-enabled (user can retry)

**Actual Results**:
```
(Describe error behavior - what happened to partial message?)

Pass: [ ] / Fail: [ ]
```

---

## Terminal Tests (CLI Verification)

### Terminal Test 1: Verify TypeScript Compilation

**Acceptance Criteria**: AC10

**Command**:
```bash
npm run build
```

**Expected Output**:
```
✅ Build completes without errors
✅ No TypeScript type errors
✅ Compiled files in packages/server/dist/ and packages/client/dist/
```

**Actual Output**:
```
(Copy build output here)

Pass: [ ] / Fail: [ ]
```

---

### Terminal Test 2: Verify Socket.io Events Emitted (Server Logs Inspection)

**Acceptance Criteria**: AC3, AC4, AC7

**Command**:
```bash
# In terminal running server (npm run dev)
# Send message via browser, then inspect server logs
```

**Expected Output**:
```
✅ Logs contain: "Streaming started" with messageId
✅ Logs contain: Multiple "Chunk N received" entries (N = 0, 1, 2, ...)
✅ Logs contain: "Streaming complete" with totalChunks count
✅ Logs show component: 'AgentEventLoop'
✅ Each log entry includes messageId for traceability
```

**Actual Output**:
```
(Copy relevant server log lines here)

Pass: [ ] / Fail: [ ]
```

---

### Terminal Test 3: Verify Event Types Defined in Shared Package

**Acceptance Criteria**: AC3, AC4

**Command**:
```bash
# Verify shared types file exists and exports streaming events
cat packages/shared/src/types.ts | grep -A 5 "AgentResponseChunk"
cat packages/shared/src/types.ts | grep -A 5 "AgentResponseComplete"
```

**Expected Output**:
```typescript
✅ AgentResponseChunkEvent interface defined:
export interface AgentResponseChunkEvent {
  event: 'agent_response_chunk';
  payload: {
    content: string;
    messageId: string;
    chunkIndex?: number;
  };
}

✅ AgentResponseCompleteEvent interface defined:
export interface AgentResponseCompleteEvent {
  event: 'agent_response_complete';
  payload: {
    messageId: string;
  };
}

✅ Both events included in SocketEvent union type
```

**Actual Output**:
```
(Copy grep output or manually verify types.ts content)

Pass: [ ] / Fail: [ ]
```

---

## Test Data Suggestions

### Short Message Test (Fast Streaming)
```
Input: "Count to 5"
Expected: Quick streaming (5-10 chunks)
Use for: Basic streaming verification
```

### Long Message Test (Extended Streaming)
```
Input: "Tell me a detailed story about a robot learning to paint. Include the robot's emotions and struggles."
Expected: Extended streaming (50+ chunks)
Use for: Stress testing streaming lifecycle
```

### Error Test (Interruption Simulation)
```
Input: "Tell me a story about a robot" (then interrupt network/server)
Expected: Partial message with error handling
Use for: Error handling verification
```

### Rapid Message Test (Queue Handling)
```
Input 1: "Count to 3"
Input 2: "Count to 5"
Input 3: "Count to 7"
(Send all three rapidly)
Expected: Three separate responses, no cross-contamination
Use for: Message queue verification
```

---

## Critical Verification Points from Story 2.3 AC

### AC3: agent_response_chunk Events with messageId and chunkIndex
- ✅ Verify event payload includes `content` (string)
- ✅ Verify event payload includes `messageId` (string)
- ✅ Verify event payload includes `chunkIndex` (number, starting at 0)
- ✅ Verify chunks emitted immediately (not batched)

### AC4: agent_response_complete Event After Final Chunk
- ✅ Verify `agent_response_complete` emitted AFTER all chunks
- ✅ Verify event payload includes `messageId` matching chunk events
- ✅ Verify no chunks emitted after complete event

### AC5-6: Client Handles Chunk and Complete Events
- ✅ Verify client appends chunks to existing message (not creates new messages)
- ✅ Verify first chunk creates new assistant message
- ✅ Verify subsequent chunks append to same message
- ✅ Verify `agent_response_complete` re-enables input field

### AC7: Console Logging Shows Streaming Stages
- ✅ Verify server logs: "Streaming started" before first chunk
- ✅ Verify server logs: "Chunk N received" for each chunk (with chunk number)
- ✅ Verify server logs: "Streaming complete" with totalChunks count
- ✅ Verify all logs include component: 'AgentEventLoop'

### AC8: Manual Test with Long Response
- ✅ Use test message: "Tell me a story about a robot learning to paint"
- ✅ Verify response appears progressively (word-by-word or sentence-by-sentence)
- ✅ Verify NOT: Response appears all at once

### AC9: Error Handling for Streaming Interruptions
- ✅ Verify partial message visible if streaming fails mid-stream
- ✅ Verify error event emitted to client
- ✅ Verify partial message marked with error status
- ✅ Verify input field re-enabled after error

---

## Pass/Fail Criteria

### Overall Pass Criteria

**All of the following must be true**:

1. ✅ **TypeScript builds without errors** (Terminal Test 1)
2. ✅ **Streaming infrastructure loads** (Human Test 1)
3. ✅ **Progressive response display works** (Human Test 2)
4. ✅ **Server logs show streaming lifecycle** (Human Test 3)
5. ✅ **Browser console shows chunk reception** (Human Test 4)
6. ✅ **Message completion works** (Human Test 5)
7. ✅ **Multiple messages queue correctly** (Human Test 6)
8. ✅ **Error handling works** (Human Test 7)
9. ✅ **Shared types defined correctly** (Terminal Test 3)
10. ✅ **Event loop code remains minimal** (visual inspection of event-loop.ts - should be ~125 lines)

### Fail Criteria (Any of these = FAIL)

- ❌ TypeScript build fails
- ❌ Response appears all at once (not progressively)
- ❌ Server logs missing streaming lifecycle logs
- ❌ Client doesn't append chunks (creates new messages instead)
- ❌ `agent_response_complete` doesn't re-enable input
- ❌ Multiple messages cross-contaminate (chunks appear in wrong message)
- ❌ Error handling doesn't work (app crashes or hangs on interruption)
- ❌ Shared types missing AgentResponseChunkEvent or AgentResponseCompleteEvent

---

## Testing Notes

### Testing Order

**Recommended sequence**:
1. Run Terminal Test 1 first (verify build)
2. Run Human Test 1 (verify infrastructure)
3. Run Human Test 2-5 (core streaming functionality)
4. Run Human Test 6 (queue handling)
5. Run Human Test 7 (error handling)
6. Run Terminal Tests 2-3 (verify implementation details)

### Common Issues to Watch For

**Issue 1: Response Appears All at Once**
- Symptom: Message appears complete immediately
- Cause: Event loop collecting chunks instead of streaming
- Solution: Verify event-loop.ts emits chunks immediately in `for await` loop

**Issue 2: Chunks Create New Messages Instead of Appending**
- Symptom: Each chunk creates a new assistant message
- Cause: Client not tracking `currentStreamingMessageId`
- Solution: Verify index.html uses chunkIndex 0 to create, others to append

**Issue 3: Input Field Never Re-Enables**
- Symptom: Input field stays disabled after streaming
- Cause: `agent_response_complete` event not received or not handled
- Solution: Verify event-loop.ts emits complete event after generator finishes

**Issue 4: Cross-Contamination Between Messages**
- Symptom: Chunks from message 2 appear in message 1's response
- Cause: `currentStreamingMessageId` not reset properly
- Solution: Verify client resets tracking variable on `agent_response_complete`

**Issue 5: Server Logs Missing Chunk Numbers**
- Symptom: Logs show "Streaming started" and "Streaming complete" but no "Chunk N received"
- Cause: Chunk extraction failing (returns empty string)
- Solution: Verify chunk parsing logic extracts text from `chunk.message.content[].text`

---

## QA Sign-Off

**Tester Name**: ___________________________

**Date**: ___________________________

**Overall Result**: Pass [ ] / Fail [ ]

**Human Tests Passed**: ___ / 7

**Terminal Tests Passed**: ___ / 3

**Critical Issues Found**:
```
(List any critical issues that block story completion)
```

**Non-Critical Issues Found**:
```
(List any minor issues or improvements)
```

**Comments**:
```
(Additional observations or notes)
```

---

**Story 2.3 Status**: ___________________________

**Ready for Next Story (2.4)**: Yes [ ] / No [ ]

**If No, Required Actions**:
```
(List what needs to be fixed before moving to Story 2.4)
```
