# Story 2.6 - Acceptance Test Guide

## Quick Summary

**Story**: Implement Custom Tools for /public Directory File Operations
**Status**: Review
**Test Focus**: Verify four custom tools (`list_files`, `preview_file`, `read_file`, `write_file`) enable agent to discover, inspect, and generate HTML/CSS/JS files in /public directory with proper path sandboxing, discovery workflows, and browser verification

## Prerequisites

**Before testing, ensure:**
- [ ] Story status is "Review"
- [ ] Server is not running
- [ ] Required dependencies installed (`npm install` from project root)
- [ ] Claude authentication complete (`claude auth login` - only if running server tests)
- [ ] `public/` directory exists (created by Story 1.2, contains Express static files)
- [ ] `data/products.json` exists from Story 2.5 testing (needed for multi-tool integration tests)

**Environment Setup:**
- Node.js: >=18.0.0
- Server Port: 3000 (for both API and static file serving)
- Working directory: `/Users/davidcruwys/dev/ad/appydave-app-a-day/007-bmad-claude-sdk`
- Browser: Chrome, Firefox, Safari, or Edge (for HTML rendering verification)

---

## ü§ñ Terminal Tests (Scriptable)

Tests using command-line tools - can run without starting server.

### Test A: AC1, AC2 - list_files tool implementation with pattern filtering

**What to test**: Tool file exists and exports listFilesTool with correct structure and file type filtering

**Command**:
```bash
cat packages/server/src/tools/list-files.ts | grep -E "(export const listFilesTool|tool\(|pattern.*z\.string|ALLOWED_EXTENSIONS)"
```

**Expected Output**:
```
const ALLOWED_EXTENSIONS = ['.html', '.css', '.js', '.jsx', '.ts', '.tsx'];
export const listFilesTool = tool(
    pattern: z.string().optional().describe('Optional search pattern to filter filenames (case-insensitive, partial match)'),
```

**Validation**:
- ‚úÖ File exists at `packages/server/src/tools/list-files.ts`
- ‚úÖ Exports `listFilesTool` constant
- ‚úÖ Uses Agent SDK's `tool()` function
- ‚úÖ Parameters use Zod schema (`z.string().optional()`)
- ‚úÖ Defines ALLOWED_EXTENSIONS for HTML/CSS/JS filtering

**Status**: ‚úÖ Passed

**Notes**: Tool implementation confirmed with file type filtering (.html, .css, .js, .jsx, .ts, .tsx only - no images).

---

### Test B: AC5, AC6 - preview_file tool implementation with maxLines parameter

**What to test**: Tool file exists with preview functionality

**Command**:
```bash
cat packages/server/src/tools/preview-file.ts | grep -E "(export const previewFileTool|tool\(|filepath.*z\.string|maxLines.*z\.number)"
```

**Expected Output**:
```
export const previewFileTool = tool(
    filepath: z.string().describe('Relative path to file within /public directory (e.g., "index.html" or "pages/about.html")'),
    maxLines: z.number().optional().default(20).describe('Maximum number of lines to preview (default: 20)'),
```

**Validation**:
- ‚úÖ File exists at `packages/server/src/tools/preview-file.ts`
- ‚úÖ Exports `previewFileTool` constant
- ‚úÖ Has `filepath` parameter (required)
- ‚úÖ Has `maxLines` parameter (optional, default 20)
- ‚úÖ Uses validatePath for path sandboxing

**Status**: ‚úÖ Passed

**Notes**: Preview tool enables inspection of file structure before full read (first N lines).

---

### Test C: AC9, AC10, AC11 - read_file tool implementation

**What to test**: Tool file exists and reads complete file content

**Command**:
```bash
cat packages/server/src/tools/read-file.ts | grep -E "(export const readFileTool|tool\(|filepath.*z\.string|validatePath)"
```

**Expected Output**:
```
export const readFileTool = tool(
    filepath: z.string().describe('Relative path to file within /public directory (e.g., "index.html")'),
      const fullPath = validatePath(filepath, PUBLIC_DIR);
```

**Validation**:
- ‚úÖ File exists at `packages/server/src/tools/read-file.ts`
- ‚úÖ Exports `readFileTool` constant
- ‚úÖ Uses Agent SDK's `tool()` function
- ‚úÖ Uses `validatePath()` for path sandboxing (AC14)
- ‚úÖ Reads complete file content (AC10, AC11)

**Status**: ‚úÖ Passed

**Notes**: Read tool returns full file content for agent modification workflows.

---

### Test D: AC12, AC13 - write_file tool implementation with directory creation

**What to test**: Tool file exists and supports nested path creation

**Command**:
```bash
cat packages/server/src/tools/write-file.ts | grep -E "(export const writeFileTool|tool\(|filepath.*z\.string|content.*z\.string|mkdir.*recursive)"
```

**Expected Output**:
```
export const writeFileTool = tool(
    filepath: z.string().describe('Relative path to the file within /public directory (e.g., "index.html" or "pages/products.html")'),
    content: z.string().describe('Text content to write to the file (HTML, CSS, JavaScript, or any text format)'),
      await fs.mkdir(path.dirname(fullPath), { recursive: true });
```

**Validation**:
- ‚úÖ File exists at `packages/server/src/tools/write-file.ts`
- ‚úÖ Exports `writeFileTool` constant
- ‚úÖ Has `filepath` parameter (string)
- ‚úÖ Has `content` parameter (string, not JSON.stringify)
- ‚úÖ Creates directories with `recursive: true` (AC13)

**Status**: ‚úÖ Passed

**Notes**: Write tool supports nested paths like "pages/products.html" with automatic directory creation.

---

### Test E: AC14 - Path sandboxing for all four tools

**What to test**: All tools use validatePath() to enforce PUBLIC_DIR restriction

**Command**:
```bash
grep -r "validatePath" packages/server/src/tools/{list-files,preview-file,read-file,write-file}.ts | grep -v "^Binary"
```

**Expected Output**:
```
packages/server/src/tools/preview-file.ts:import { validatePath } from '../utils/path-validator.js';
packages/server/src/tools/preview-file.ts:      const fullPath = validatePath(filepath, PUBLIC_DIR);
packages/server/src/tools/read-file.ts:import { validatePath } from '../utils/path-validator.js';
packages/server/src/tools/read-file.ts:      const fullPath = validatePath(filepath, PUBLIC_DIR);
packages/server/src/tools/write-file.ts:import { validatePath } from '../utils/path-validator.js';
packages/server/src/tools/write-file.ts:      const fullPath = validatePath(filepath, PUBLIC_DIR);
```

**Validation**:
- ‚úÖ `preview_file` uses validatePath (AC14)
- ‚úÖ `read_file` uses validatePath (AC14)
- ‚úÖ `write_file` uses validatePath (AC14)
- ‚úÖ `list_files` doesn't need validatePath (only lists PUBLIC_DIR, no user path input)
- ‚úÖ All tools define `PUBLIC_DIR = path.join(process.cwd(), 'public')`

**Status**: ‚úÖ Passed

**Notes**: Path sandboxing prevents directory traversal attacks - only /public directory accessible.

---

### Test F: AC15 - All tools registered with Agent SDK

**What to test**: Tools are imported and registered in agent configuration

**Command**:
```bash
cat packages/server/src/agent/agent-config.ts | grep -E "(import.*Tool.*tools|listFilesTool|previewFileTool|readFileTool|writeFileTool)" | head -10
```

**Expected Output**:
```
import { listFilesTool } from '../tools/list-files.js';
import { previewFileTool } from '../tools/preview-file.js';
import { readFileTool } from '../tools/read-file.js';
import { writeFileTool } from '../tools/write-file.js';
      tools: [listJsonTool, previewJsonTool, readJsonTool, writeJsonTool, listFilesTool, previewFileTool, readFileTool, writeFileTool],
```

**Validation**:
- ‚úÖ All four tools imported from `../tools/` directory
- ‚úÖ All four tools added to MCP server `tools` array
- ‚úÖ MCP server is added to `mcpServers` option in agent initialization

**Status**: ‚úÖ Passed

**Notes**: All eight tools now registered (4 JSON tools from Stories 2.4/2.5 + 4 file tools from Story 2.6).

---

### Test G: AC15 - All tools in allowedTools array with correct MCP naming

**What to test**: Tools are in permission configuration with correct naming convention

**Command**:
```bash
cat packages/server/src/agent/agent-config.ts | grep -E "mcp__agent-tools__(list_files|preview_file|read_file|write_file)"
```

**Expected Output**:
```
        'mcp__agent-tools__list_files',      // Story 2.6: Discover HTML/CSS/JS files
        'mcp__agent-tools__preview_file',    // Story 2.6: Preview first N lines
        'mcp__agent-tools__read_file',       // Story 2.6: Read complete file content
        'mcp__agent-tools__write_file',      // Story 2.6: Create/update files
```

**Validation**:
- ‚úÖ `mcp__agent-tools__list_files` in allowedTools
- ‚úÖ `mcp__agent-tools__preview_file` in allowedTools
- ‚úÖ `mcp__agent-tools__read_file` in allowedTools
- ‚úÖ `mcp__agent-tools__write_file` in allowedTools
- ‚úÖ All use correct MCP naming convention

**Status**: ‚úÖ Passed

**Notes**: Permission mode should be `acceptEdits` (set in Story 2.4).

---

### Test H: AC16 - Tool descriptions document purpose and restrictions

**What to test**: All tools have clear, comprehensive descriptions

**Command**:
```bash
for tool in list-files preview-file read-file write-file; do
  echo "=== $tool ==="
  grep -A 2 "tool(" packages/server/src/tools/$tool.ts | head -3
  echo ""
done
```

**Expected Output**:
```
=== list-files ===
export const listFilesTool = tool(
  'list_files',
  'List all HTML/CSS/JS files in the /public directory...'

=== preview-file ===
export const previewFileTool = tool(
  'preview_file',
  'Preview first N lines of a file in /public directory...'

=== read-file ===
export const readFileTool = tool(
  'read_file',
  'Read complete contents of a file in /public directory...'

=== write-file ===
export const writeFileTool = tool(
  'write_file',
  'Write or update a file in the /public directory...'
```

**Validation**:
- ‚úÖ Each tool has descriptive second parameter (description string)
- ‚úÖ Descriptions explain purpose (list/preview/read/write)
- ‚úÖ Descriptions mention path restriction (/public directory)
- ‚úÖ Descriptions note special behaviors (pattern filtering, directory creation)

**Status**: ‚úÖ Passed

**Notes**: Tool descriptions are clear and educational for agent understanding.

---

### Test I: AC17 - Error handling implementation

**What to test**: All tools handle errors and return CallToolResult with isError flag

**Command**:
```bash
for tool in list-files preview-file read-file write-file; do
  echo "=== $tool ==="
  grep -E "(catch|ENOENT|ToolError|isError)" packages/server/src/tools/$tool.ts | head -5
  echo ""
done
```

**Expected Output**:
```
=== list-files ===
    } catch (error) {
        isError: true,

=== preview-file ===
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      if (error instanceof ToolError) {
        isError: true,

=== read-file ===
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      if (error instanceof ToolError) {
        isError: true,

=== write-file ===
    } catch (error) {
      if (error instanceof ToolError) {
        isError: true,
```

**Validation**:
- ‚úÖ All tools have try/catch blocks
- ‚úÖ Tools check for ENOENT (file not found) where applicable
- ‚úÖ Tools check for ToolError (path traversal)
- ‚úÖ All tools return CallToolResult with `isError: true` on failure
- ‚úÖ No tools throw errors (Agent SDK expects CallToolResult return)

**Status**: ‚úÖ Passed

**Notes**: Comprehensive error handling prevents server crashes and provides user-friendly error messages.

---

### Test J: AC18 - Logging implementation with component prefix

**What to test**: All tools log operations with proper component naming

**Command**:
```bash
for tool in list-files preview-file read-file write-file; do
  echo "=== $tool ==="
  grep -E "logger\.(debug|info|error)" packages/server/src/tools/$tool.ts | head -3
  echo ""
done
```

**Expected Output**:
```
=== list-files ===
      logger.debug(`Listing files in public directory${pattern ? ` (pattern: "${pattern}")` : ''}`, {
      logger.info(`Found ${filesWithStats.length} web file(s)`, {
      logger.error(`Error listing files: ${(error as Error).message}`, {

=== preview-file ===
      logger.debug(`Previewing file: ${fullPath}`, { component: 'Tool:preview_file' });
      logger.info(`Previewed ${filepath}`, {
      logger.error(errorMsg, { component: 'Tool:preview_file' });

=== read-file ===
      logger.debug(`Reading file: ${fullPath}`, { component: 'Tool:read_file' });
      logger.info(`Successfully read ${filepath}`, {
      logger.error(errorMsg, { component: 'Tool:read_file' });

=== write-file ===
      logger.debug(`Writing file: ${fullPath}`, { component: 'Tool:write_file' });
      logger.info(`File written: ${filepath}`, {
      logger.error(errorMsg, { component: 'Tool:write_file' });
```

**Validation**:
- ‚úÖ All tools use `logger.debug()` for operation start
- ‚úÖ All tools use `logger.info()` for success with metadata
- ‚úÖ All tools use `logger.error()` for failures
- ‚úÖ All logs include `component: 'Tool:<tool_name>'` for filtering

**Status**: ‚úÖ Passed

**Notes**: Structured logging with component prefix enables debugging and educational transparency.

---

### Test K: AC22 - Shared TypeScript types defined

**What to test**: Type interfaces exist in shared package

**Command**:
```bash
cat packages/shared/src/types.ts | grep -E "(ListFilesParams|PreviewFileParams|ReadFileParams|WriteFileParams)" -A 3
```

**Expected Output**:
```
export interface ListFilesParams {
  pattern?: string;
}

export interface PreviewFileParams {
  filepath: string;
  maxLines?: number;
}

export interface ReadFileParams {
  filepath: string;
}

export interface WriteFileParams {
  filepath: string;
  content: string;
}
```

**Validation**:
- ‚úÖ `ListFilesParams` interface defined with optional `pattern`
- ‚úÖ `PreviewFileParams` interface defined with `filepath` and optional `maxLines`
- ‚úÖ `ReadFileParams` interface defined with `filepath`
- ‚úÖ `WriteFileParams` interface defined with `filepath` and `content`
- ‚úÖ All interfaces exported for cross-package use

**Status**: ‚úÖ Passed

**Notes**: Shared types maintain type safety across client/server boundary for all file operations.

---

## üßë Human Tests (Visual/Manual)

Tests requiring human observation - server running, agent interaction, browser verification.

### Test 1: AC2, AC3, AC4 - Discovery workflow with list_files

**What to test**: Agent can discover HTML/CSS/JS files in /public directory with pattern filtering

**Prerequisites**:
- Start server: `npm run dev:server`
- Wait for "Server started on port 3000" message
- Have a client ready (HTML page or curl for socket.io)

**Steps**:
1. Connect to server via Socket.io client
2. Send message: "What HTML files exist in the public directory?"
3. Observe terminal output for tool execution logs
4. Wait for agent response to stream back
5. Send message: "Show me files with 'page' in the name"
6. Observe pattern filtering behavior

**Expected Result**:
‚úÖ Terminal shows (first query):
- Blue timestamp in ISO 8601 format
- `[Tool:list_files] Listing files in public directory` (debug log)
- `[Tool:list_files] Found N web file(s)` with metadata (info log showing count)

‚úÖ Agent response streams back:
- List of HTML/CSS/JS files in /public directory
- File metadata: filename, size, modified date, type
- File count information

‚úÖ Terminal shows (second query with pattern):
- `[Tool:list_files] Listing files in public directory (pattern: "page")` (debug log)
- Filtered results showing only files with "page" in name

‚úÖ Pattern matching works:
- Case-insensitive partial match
- "page" matches "page.html", "landing-page.css", "pages/about.html"

**Evidence**:
- Screenshot of terminal showing colored logs with timestamps
- Agent response showing file list with metadata
- Pattern filtering demonstration

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 2: AC5, AC6, AC7, AC8 - Preview workflow with preview_file

**What to test**: Agent can preview first N lines of files to understand structure

**Prerequisites**:
- Server running from Test 1
- At least one HTML file exists in /public directory

**Steps**:
1. Send message: "Show me a preview of index.html"
2. Observe terminal logs
3. Observe agent response with preview content
4. Send message: "Show me the first 10 lines of index.html"
5. Verify maxLines parameter works

**Expected Result**:
‚úÖ Terminal shows:
- Debug log: `Previewing file: .../public/index.html`
- Info log: `Previewed index.html` with metadata (file size, total lines, preview lines)

‚úÖ Agent response includes:
- Filename and file size
- Total line count in file
- First 20 lines by default (or specified maxLines)
- Preview snippet showing file structure
- Note explaining this is a preview (not full content)

‚úÖ Custom maxLines works:
- When requesting "first 10 lines", preview shows exactly 10 lines
- Metadata indicates 10/N lines shown

**Evidence**:
- Terminal screenshot showing preview logs
- Agent response with preview content
- Demonstration of custom maxLines parameter

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 3: AC9, AC10, AC11 - Read workflow with read_file

**What to test**: Agent can read complete file content for modification

**Prerequisites**:
- Server running
- HTML file exists in /public directory

**Steps**:
1. Send message: "Read the complete contents of index.html"
2. Observe terminal logs
3. Observe agent response with full file content

**Expected Result**:
‚úÖ Terminal shows:
- Debug log: `Reading file: .../public/index.html`
- Info log: `Successfully read index.html` with metadata (file size)

‚úÖ Agent response includes:
- Complete file content (all lines, not just preview)
- Confirmation of successful read operation
- May summarize content structure

‚úÖ Content is complete:
- Full HTML from `<!DOCTYPE html>` to closing `</html>`
- All whitespace and formatting preserved
- No truncation or preview limitation

**Evidence**:
- Terminal screenshot showing read logs
- Agent response confirming full content read
- Comparison with actual file to verify completeness

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 4: AC12, AC13, AC18 - Basic HTML write with write_file

**What to test**: Agent can create new HTML file in /public directory

**Prerequisites**:
- Server running
- Browser ready for verification

**Steps**:
1. Send message: "Create an index.html file with a simple welcome page. Include a heading 'Welcome to BMAD App', a paragraph explaining this is a self-editing app, and basic HTML structure."
2. Observe terminal logs
3. Wait for agent response
4. Verify file created: `ls -la public/index.html`
5. Open browser to `http://localhost:3000/index.html`
6. Verify page renders correctly

**Expected Result**:
‚úÖ Terminal shows:
- Debug log: `Writing file: .../public/index.html`
- Info log: `File written: index.html` with metadata (file size)

‚úÖ Agent response streams back:
- Confirmation of file creation
- Filepath and success status
- May include brief description of content

‚úÖ File created at `public/index.html`:
- Valid HTML5 structure (`<!DOCTYPE html>`, `<html>`, `<head>`, `<body>`)
- Contains heading "Welcome to BMAD App"
- Contains paragraph with description
- May include basic CSS styling

‚úÖ Browser verification:
- Page loads at `http://localhost:3000/index.html`
- Heading displays correctly
- Content is readable and properly formatted
- No console errors in browser DevTools

**Evidence**:
- Terminal screenshot showing write logs
- File contents of `public/index.html`
- Browser screenshot showing rendered page
- Agent confirmation message

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 5: AC13 - Nested directory creation with write_file

**What to test**: Tool creates parent directories when writing to nested paths

**Prerequisites**:
- Server running
- `public/pages/` directory does NOT exist yet

**Steps**:
1. Send message: "Create pages/about.html with an about page. Include information about the BMAD Method and Claude Agent SDK."
2. Observe terminal logs
3. Verify directory created: `ls -la public/pages/`
4. Verify file created: `cat public/pages/about.html`
5. Open browser to `http://localhost:3000/pages/about.html`

**Expected Result**:
‚úÖ Terminal shows:
- Debug log: `Writing file: .../public/pages/about.html`
- Info log: `File written: pages/about.html` with metadata

‚úÖ Directory created:
- `public/pages/` directory exists
- Created automatically by tool (not manually)

‚úÖ File created:
- `public/pages/about.html` contains about page content
- Valid HTML structure
- Includes BMAD and Agent SDK information

‚úÖ Browser verification:
- Page loads at `http://localhost:3000/pages/about.html`
- Content renders correctly
- No 404 errors

**Evidence**:
- Terminal screenshot showing successful write
- Directory listing showing `public/pages/` exists
- Contents of `public/pages/about.html`
- Browser screenshot of rendered page

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 6: AC19, AC20 - Multi-tool integration: HTML from JSON data

**What to test**: Agent uses read_json + write_file to create data-driven HTML pages

**Prerequisites**:
- Server running
- `data/products.json` exists from Story 2.5 testing (with sample products)

**Steps**:
1. Send message: "Create products.html that displays all products from products.json in a nice HTML page. Include a table with columns for ID, Name, Price, and Description. Add some basic CSS styling."
2. Observe terminal logs for multi-tool workflow
3. Verify file created: `cat public/products.html`
4. Open browser to `http://localhost:3000/products.html`
5. Verify all products from JSON are displayed

**Expected Result**:
‚úÖ Terminal shows tool execution sequence:
- `[Tool:read_json] Reading JSON file: .../data/products.json` (agent reads data)
- `[Tool:write_file] Writing file: .../public/products.html` (agent creates HTML)
- Success logs for both operations

‚úÖ File created at `public/products.html`:
- Contains HTML table or list structure
- All products from JSON file are included
- Data accurately mapped: IDs, names, prices, descriptions
- Includes basic CSS styling (inline or `<style>` tag)

‚úÖ Browser verification:
- Page loads at `http://localhost:3000/products.html`
- All products display correctly in table/list format
- Prices formatted properly (currency)
- Styling makes page readable and visually appealing
- No missing data or rendering errors

‚úÖ Agent demonstrates integration:
- Explains workflow: "I'll read products.json and create an HTML page"
- Confirms both operations completed successfully

**Evidence**:
- Terminal screenshot showing read_json ‚Üí write_file sequence
- Contents of `public/products.html`
- Browser screenshot showing all products rendered
- Comparison with `data/products.json` to verify data accuracy

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 7: AC19 - Update workflow: read_file ‚Üí modify ‚Üí write_file

**What to test**: Agent can update existing files using discovery ‚Üí read ‚Üí modify ‚Üí write pattern

**Prerequisites**:
- Server running
- `public/index.html` exists from Test 4

**Steps**:
1. Send message: "Add a navigation menu to index.html with links to Home, About, and Products pages"
2. Observe terminal logs for multi-tool workflow
3. Verify file updated: `cat public/index.html`
4. Refresh browser at `http://localhost:3000/index.html`
5. Verify navigation menu appears

**Expected Result**:
‚úÖ Terminal shows tool execution sequence:
- Optional: `[Tool:list_files]` or `[Tool:preview_file]` (discovery)
- `[Tool:read_file] Reading file: .../public/index.html` (get current content)
- `[Tool:write_file] Writing file: .../public/index.html` (save updated content)
- Success logs for all operations

‚úÖ File updated correctly:
- Original content preserved (heading, paragraph)
- Navigation menu added (typically in `<nav>` or `<header>`)
- Links include: Home, About (`pages/about.html`), Products (`products.html`)
- HTML structure remains valid

‚úÖ Browser verification:
- Refresh `http://localhost:3000/index.html`
- Navigation menu appears on page
- Links are clickable and navigate to correct pages
- Styling is consistent with existing page

‚úÖ Agent demonstrates update workflow:
- Explains: "I'll read the current file, add navigation, and update it"
- Confirms successful update operation
- May describe what was changed

**Evidence**:
- Terminal screenshot showing read ‚Üí write sequence
- Before/after comparison of `public/index.html`
- Browser screenshot showing navigation menu
- Verification that links work

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 8: AC21 - CSS file creation and browser rendering

**What to test**: Agent can create CSS files and they load correctly in browser

**Prerequisites**:
- Server running
- `public/products.html` exists from Test 6

**Steps**:
1. Send message: "Create styles.css with styling for products.html. Include a nice color scheme, table borders, hover effects on rows, and responsive layout."
2. Observe terminal logs
3. Verify file created: `cat public/styles.css`
4. Send follow-up message: "Update products.html to link to styles.css"
5. Refresh browser at `http://localhost:3000/products.html`
6. Verify styles are applied

**Expected Result**:
‚úÖ Terminal shows:
- `[Tool:write_file] Writing file: .../public/styles.css` (CSS creation)
- `[Tool:read_file] Reading file: .../public/products.html` (read HTML)
- `[Tool:write_file] Writing file: .../public/products.html` (update HTML with `<link>`)

‚úÖ CSS file created at `public/styles.css`:
- Contains valid CSS syntax
- Includes table styling (borders, spacing)
- Includes hover effects (`:hover` selector)
- Includes color scheme (background, text colors)
- May include responsive design rules (`@media`)

‚úÖ HTML updated:
- Contains `<link rel="stylesheet" href="styles.css">` in `<head>`
- Link path is correct (relative path)

‚úÖ Browser verification:
- Refresh `http://localhost:3000/products.html`
- Styles are applied to table/list
- Hover effects work on table rows
- Color scheme is visually appealing
- No broken CSS (check browser DevTools Console)
- CSS file loads: `http://localhost:3000/styles.css` returns CSS content

**Evidence**:
- Terminal screenshot showing file operations
- Contents of `public/styles.css`
- Browser screenshot showing styled page
- Browser DevTools Network tab showing CSS file loaded (200 OK)

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 9: AC21 - JavaScript file creation and execution

**What to test**: Agent can create JavaScript files and they execute in browser

**Prerequisites**:
- Server running
- `public/products.html` exists

**Steps**:
1. Send message: "Create script.js that adds interactivity to products.html. Add a filter feature that lets users filter products by typing in a search box."
2. Observe terminal logs
3. Verify file created: `cat public/script.js`
4. Send follow-up message: "Update products.html to include a search input and link to script.js"
5. Refresh browser at `http://localhost:3000/products.html`
6. Test search functionality

**Expected Result**:
‚úÖ Terminal shows:
- `[Tool:write_file] Writing file: .../public/script.js` (JS creation)
- `[Tool:read_file]` + `[Tool:write_file]` for products.html update

‚úÖ JavaScript file created at `public/script.js`:
- Contains valid JavaScript syntax
- Includes search/filter functionality
- Uses DOM manipulation (querySelector, addEventListener, etc.)
- May include comments explaining functionality

‚úÖ HTML updated:
- Contains `<script src="script.js"></script>` before closing `</body>` tag
- Includes search input element (`<input type="text">`)
- Elements have IDs or classes for JavaScript targeting

‚úÖ Browser verification:
- Refresh `http://localhost:3000/products.html`
- Search input appears on page
- Typing in search box filters products in real-time
- Filtering works correctly (shows matching products, hides non-matching)
- No JavaScript errors in browser DevTools Console
- JavaScript file loads: `http://localhost:3000/script.js` returns JS content

**Evidence**:
- Terminal screenshot showing file operations
- Contents of `public/script.js`
- Browser screenshot showing search feature
- Video/GIF demonstrating filtering in action
- Browser DevTools Console showing no errors

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 10: AC17 - Path traversal attempt blocked

**What to test**: validatePath() prevents directory traversal attacks for all file tools

**Prerequisites**:
- Server running

**Steps**:
1. Send message: "Create a file at ../etc/config.html with some test data"
2. Observe terminal error log
3. Observe agent response
4. Verify file NOT created: `ls -la ../etc/config.html` (should fail)
5. Test other traversal attempts: "../data/bad.html", "/etc/passwd", "../../secret.html"

**Expected Result**:
‚úÖ Terminal shows:
- Error log from tool (write_file, read_file, or preview_file)
- ToolError message about path traversal
- Error details include blocked path
- Component prefix: `[Tool:write_file]` or similar

‚úÖ Agent response:
- Error message streamed back to client
- Explains path restriction (only /public directory writable)
- May suggest correct path format (e.g., "pages/config.html")
- Does NOT create the file

‚úÖ File system:
- No file created outside /public directory
- `public/` directory remains secure
- No files in parent directories (../)
- No absolute paths created (/etc/, /tmp/)

‚úÖ All tools protected:
- write_file blocks "../" paths
- read_file blocks "../" paths
- preview_file blocks "../" paths
- list_files only scans PUBLIC_DIR (no user path input)

**Evidence**:
- Terminal screenshot showing ToolError logs
- Agent error response messages for multiple traversal attempts
- File system verification showing no files created outside /public
- Testing of multiple path traversal patterns

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 11: AC17 - File not found error handling

**What to test**: Tools handle missing files gracefully with user-friendly errors

**Prerequisites**:
- Server running

**Steps**:
1. Send message: "Read the file missing.html"
2. Observe terminal error log
3. Observe agent response
4. Send message: "Show me a preview of nonexistent.css"
5. Verify both tools handle ENOENT error

**Expected Result**:
‚úÖ Terminal shows (for read_file):
- Error log: `[Tool:read_file]` with ENOENT message
- Error includes filename: "missing.html"
- User-friendly error text

‚úÖ Agent response (for read_file):
- Error message streamed back
- Explains file doesn't exist
- May suggest using list_files to see available files
- Does NOT crash or show stack trace

‚úÖ Terminal shows (for preview_file):
- Error log: `[Tool:preview_file]` with ENOENT message
- Similar user-friendly error handling

‚úÖ Agent behavior:
- Handles errors gracefully
- May proactively use list_files to show what files DO exist
- Offers to create the file instead

**Evidence**:
- Terminal screenshots showing ENOENT error handling
- Agent error responses for missing files
- Demonstration that server continues running (no crash)

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 12: AC2, AC3, AC4 - File type filtering (HTML/CSS/JS only, no images)

**What to test**: list_files only returns text-based web files, not images or binary files

**Prerequisites**:
- Server running
- Copy some test files to public/ directory:
  - HTML file (e.g., `test.html`)
  - CSS file (e.g., `test.css`)
  - JS file (e.g., `test.js`)
  - Image file (e.g., `logo.png` - copy any PNG)
  - PDF file (e.g., `doc.pdf` - copy any PDF)

**Setup Commands**:
```bash
touch public/test.html public/test.css public/test.js
# Copy or create a PNG and PDF file in public/ for testing
```

**Steps**:
1. Send message: "What files are in the public directory?"
2. Observe agent response and file list
3. Verify image files NOT included in results
4. Verify PDF files NOT included in results
5. Verify HTML/CSS/JS files ARE included

**Expected Result**:
‚úÖ File list includes:
- `.html` files ‚úÖ
- `.css` files ‚úÖ
- `.js` files ‚úÖ
- `.jsx` files ‚úÖ (if any exist)
- `.ts` files ‚úÖ (if any exist)
- `.tsx` files ‚úÖ (if any exist)

‚úÖ File list excludes:
- `.png` files ‚ùå
- `.jpg` files ‚ùå
- `.gif` files ‚ùå
- `.svg` files ‚ùå
- `.pdf` files ‚ùå
- `.zip` files ‚ùå
- Any other binary/image formats ‚ùå

‚úÖ Terminal log shows:
- Filtered file count matches text-based files only
- Example: "Found 3 web file(s)" (not 5 if 2 images exist)

‚úÖ Agent behavior:
- Only reports HTML/CSS/JS files
- Doesn't mention image or binary files
- Correctly identifies file types in metadata (type: "html", "css", "javascript")

**Evidence**:
- File listing from `ls -la public/` showing all files (including images)
- Agent response showing only text-based files
- Terminal log with filtered file count
- Comparison demonstrating filtering worked

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 13: AC18 - Console logging shows operation metadata

**What to test**: Success logs include relevant metadata for educational transparency

**Prerequisites**:
- Server running
- Fresh terminal view

**Steps**:
1. Send message: "Create demo.html with a demo page"
2. Observe terminal output carefully for write_file metadata
3. Send message: "What files exist?"
4. Observe terminal output for list_files metadata
5. Send message: "Preview demo.html"
6. Observe terminal output for preview_file metadata
7. Send message: "Read demo.html"
8. Observe terminal output for read_file metadata

**Expected Result**:
‚úÖ Terminal shows for write_file:
- Debug log: `Writing file: .../public/demo.html`
- Info log: `File written: demo.html` with metadata:
  - `size`: Number (bytes of content written)
  - Component: `Tool:write_file`

‚úÖ Terminal shows for list_files:
- Debug log: `Listing files in public directory`
- Info log: `Found N web file(s)` with metadata:
  - `count`: Number of files
  - `pattern`: null or string if pattern used
  - Component: `Tool:list_files`

‚úÖ Terminal shows for preview_file:
- Debug log: `Previewing file: .../public/demo.html`
- Info log: `Previewed demo.html` with metadata:
  - `fileSize`: Number (file size in bytes)
  - `totalLines`: Total lines in file
  - `previewLines`: Lines shown in preview (e.g., 20)
  - Component: `Tool:preview_file`

‚úÖ Terminal shows for read_file:
- Debug log: `Reading file: .../public/demo.html`
- Info log: `Successfully read demo.html` with metadata:
  - `size`: Number (file size in bytes)
  - Component: `Tool:read_file`

‚úÖ All logs include:
- Blue colored timestamp in ISO 8601 format
- Component prefix for filtering
- Human-readable messages

**Evidence**:
- Terminal screenshot showing all four tool executions with metadata
- Verification that metadata is accurate (compare file sizes with `ls -la`)

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

### Test 14: AC21 - Complex multi-file generation (HTML + CSS + JS together)

**What to test**: Agent can generate complete multi-file applications in single conversation

**Prerequisites**:
- Server running
- Browser ready

**Steps**:
1. Send message: "Create a simple to-do list application with:
   - tasks.html with a form to add tasks and a list to display them
   - tasks.css with modern styling (flexbox layout, nice colors, buttons)
   - tasks.js with functionality to add tasks, mark as complete, and delete tasks
   All files should work together. No backend needed - use localStorage."
2. Observe terminal logs for multi-file creation sequence
3. Verify files created: `ls -la public/tasks.*`
4. View files: `cat public/tasks.html`, `cat public/tasks.css`, `cat public/tasks.js`
5. Open browser to `http://localhost:3000/tasks.html`
6. Test full functionality:
   - Add task
   - Mark as complete
   - Delete task
   - Refresh page and verify persistence (localStorage)

**Expected Result**:
‚úÖ Terminal shows tool sequence:
- `[Tool:write_file] Writing file: .../public/tasks.html`
- `[Tool:write_file] Writing file: .../public/tasks.css`
- `[Tool:write_file] Writing file: .../public/tasks.js`
- All success logs with file sizes

‚úÖ Files created:
- `public/tasks.html` with:
  - Form with input and submit button
  - List container for tasks
  - Links to tasks.css and tasks.js
- `public/tasks.css` with:
  - Modern styling (colors, spacing, borders)
  - Flexbox or Grid layout
  - Button styles with hover effects
  - Responsive design
- `public/tasks.js` with:
  - Event listeners for form submission
  - Add task function
  - Mark complete function
  - Delete function
  - localStorage save/load functions

‚úÖ Browser verification:
- Page loads at `http://localhost:3000/tasks.html`
- Form appears and works:
  - Type task ‚Üí click Add ‚Üí task appears in list
  - Click complete ‚Üí task shows as completed (strikethrough/different color)
  - Click delete ‚Üí task removed from list
- Refresh page ‚Üí tasks persist (localStorage)
- All styles applied correctly
- No errors in browser DevTools Console

‚úÖ Agent demonstrates comprehensive understanding:
- Creates related files in logical order
- Links files correctly (HTML references CSS and JS)
- Implements complete feature (not partial)
- Code is clean, commented, and functional

**Evidence**:
- Terminal screenshot showing all three file creations
- Contents of all three files
- Browser screenshot showing styled application
- Video/GIF demonstrating full functionality (add, complete, delete, persist)
- Browser DevTools Console showing no errors

**Status**: ‚¨ú Not Tested | ‚úÖ Passed | ‚ùå Failed

**Notes**: _________________

---

## ‚è≥ Not Testable Yet

**None** - All acceptance criteria for Story 2.6 are testable now with server and browser.

---

## Test Checklist

Copy this checklist to track overall progress:

**Terminal Tests (Automated):**
- [x] Test A: list_files tool implementation with pattern filtering (AC1, AC2)
- [x] Test B: preview_file tool implementation with maxLines (AC5, AC6)
- [x] Test C: read_file tool implementation (AC9, AC10, AC11)
- [x] Test D: write_file tool implementation with directory creation (AC12, AC13)
- [x] Test E: Path sandboxing for all four tools (AC14)
- [x] Test F: All tools registered with Agent SDK (AC15)
- [x] Test G: All tools in allowedTools array (AC15)
- [x] Test H: Tool descriptions documented (AC16)
- [x] Test I: Error handling implementation (AC17)
- [x] Test J: Logging implementation (AC18)
- [x] Test K: Shared TypeScript types defined (AC22)

**Human Tests (Manual):**
- [ ] Test 1: Discovery workflow with list_files (AC2, AC3, AC4)
- [ ] Test 2: Preview workflow with preview_file (AC5, AC6, AC7, AC8)
- [ ] Test 3: Read workflow with read_file (AC9, AC10, AC11)
- [ ] Test 4: Basic HTML write with write_file (AC12, AC13, AC18)
- [ ] Test 5: Nested directory creation (AC13)
- [ ] Test 6: Multi-tool integration: HTML from JSON (AC19, AC20)
- [ ] Test 7: Update workflow: read ‚Üí modify ‚Üí write (AC19)
- [ ] Test 8: CSS file creation and browser rendering (AC21)
- [ ] Test 9: JavaScript file creation and execution (AC21)
- [ ] Test 10: Path traversal attempt blocked (AC17)
- [ ] Test 11: File not found error handling (AC17)
- [ ] Test 12: File type filtering (no images) (AC2, AC3, AC4)
- [ ] Test 13: Console logging shows metadata (AC18)
- [ ] Test 14: Complex multi-file generation (AC21)

**Overall Status**: üîÑ In Progress (11/25 tests complete - all terminal tests passed, human tests pending)

---

## Troubleshooting

### Issue: list_files returns empty array but files exist
**Symptom**: Tool executes but reports 0 files even though /public directory has HTML/CSS/JS files
**Solution**:
1. Check file extensions: Tool only returns `.html`, `.css`, `.js`, `.jsx`, `.ts`, `.tsx`
2. Verify files exist: `ls -la public/`
3. Check if files are in subdirectories (tool should find them)
4. Verify PUBLIC_DIR constant: `grep PUBLIC_DIR packages/server/src/tools/list-files.ts`

### Issue: preview_file shows wrong number of lines
**Symptom**: Preview shows fewer or more lines than expected
**Solution**:
1. Check maxLines parameter in agent's tool call (default is 20)
2. Verify file has enough lines: `wc -l public/yourfile.html`
3. Check split logic: Preview splits by newlines (`\n`)
4. Remember: Preview is first N lines, not last N lines

### Issue: Browser shows 404 for generated files
**Symptom**: Files created by agent but browser returns "Not Found"
**Solution**:
1. Verify file exists: `ls -la public/yourfile.html`
2. Check Express static file serving: `grep "express.static" packages/server/src/server.ts`
3. Verify correct URL: `http://localhost:3000/yourfile.html` (not `/public/yourfile.html`)
4. For nested files: `http://localhost:3000/pages/about.html` (matches file path)
5. Restart server if files created while server was running

### Issue: CSS/JS not loading in browser
**Symptom**: HTML loads but styles/scripts not applied
**Solution**:
1. Check link/script tags in HTML: `cat public/yourfile.html | grep -E "(link|script)"`
2. Verify paths are relative (not absolute): `href="styles.css"` not `href="/public/styles.css"`
3. Check browser DevTools Network tab for 404s on CSS/JS files
4. Verify CSS/JS files exist: `ls -la public/*.css public/*.js`
5. Check MIME types: CSS should be `text/css`, JS should be `text/javascript`

### Issue: Path traversal protection blocking valid paths
**Symptom**: Agent can't create files in subdirectories like "pages/about.html"
**Solution**:
1. This should NOT happen - subdirectories are allowed within /public
2. Check validatePath logic: `cat packages/server/src/utils/path-validator.ts`
3. Verify path is relative: "pages/about.html" NOT "/pages/about.html"
4. Check error message - it should specify what was blocked
5. Valid nested paths: "pages/about.html", "assets/css/main.css", "js/utils/helper.js"

### Issue: Agent doesn't use discovery workflow (list/preview before read/write)
**Symptom**: Agent immediately tries to read/write without checking what exists
**Solution**:
1. Check system prompt in agent-config.ts documents discovery workflow
2. Explicitly ask: "First show me what files exist, then create..."
3. Verify all tools are in allowedTools array (agent can't use blocked tools)
4. Agent may skip discovery if confident about file existence (this is okay)
5. Discovery is optional optimization, not required for functionality

### Issue: File created but content is empty or truncated
**Symptom**: write_file executes but file has no content or partial content
**Solution**:
1. Check if content parameter was empty: Review agent's tool call
2. Verify no errors in terminal: Look for error logs before success log
3. Check file encoding: Should be UTF-8 (verify with `file public/yourfile.html`)
4. Check disk space: `df -h .`
5. Check write permissions: `ls -la public/`
6. Review write_file implementation: Should use `fs.writeFile(fullPath, content, 'utf-8')`

### Issue: No logs appearing in terminal for file operations
**Symptom**: Tools execute but no debug/info logs visible
**Solution**:
1. Check logger import in tool files: `grep "import.*logger" packages/server/src/tools/*.ts`
2. Verify logger.debug/info calls exist: `grep "logger\." packages/server/src/tools/list-files.ts`
3. Check logger configuration: `cat packages/server/src/utils/logger.ts`
4. Ensure terminal supports colors (some terminals strip ANSI codes)
5. Check log level settings (debug logs may be disabled in production mode)

### Issue: Pattern filtering not working in list_files
**Symptom**: Pattern parameter provided but all files returned (not filtered)
**Solution**:
1. Check pattern is case-insensitive: "PAGE" should match "page.html"
2. Verify partial match logic: Pattern "prod" should match "products.html"
3. Check implementation: `cat packages/server/src/tools/list-files.ts | grep -A 5 "pattern"`
4. Test exact match: Use full filename as pattern
5. Remember: Pattern filters after extension filtering (only searches HTML/CSS/JS)

### Issue: Browser caching shows old file content after update
**Symptom**: File updated by agent but browser shows previous version
**Solution**:
1. Hard refresh browser: Cmd+Shift+R (Mac) or Ctrl+Shift+R (Windows/Linux)
2. Clear browser cache
3. Open browser DevTools ‚Üí Network tab ‚Üí Disable cache checkbox
4. Verify file actually updated on filesystem: `cat public/yourfile.html`
5. Check file timestamp: `ls -la public/yourfile.html` (should be recent)

### Issue: Multi-tool workflow not preserving data from read_json
**Symptom**: Agent reads JSON but generated HTML missing data or has errors
**Solution**:
1. Verify read_json succeeded: Check terminal for success log
2. Check JSON file is valid: `cat data/products.json | jq .` (requires jq tool)
3. Review agent's workflow in conversation: Agent should explain what data it read
4. Verify write_file includes data: `cat public/products.html` and look for product data
5. Check for JavaScript errors in browser: Open DevTools Console
6. This is agent behavior issue, not tool issue - prompt agent to be more careful

---

## Test Results Summary

**Date Tested**: _________________
**Tester**: _________________

**Results**:
- Terminal Tests: 11 / 11 passed ‚úÖ
- Human Tests: __ / 14 passed
- Total: __ / 25 passed

**Issues Found**:
1. _________________
2. _________________

**Sign-off**: ‚¨ú Story accepted | ‚ùå Issues require fixes

---

## Test Data Files

The following test data files may be created during testing:

**Created by Tests:**
- `public/index.html` - Welcome page (Test 4)
- `public/pages/about.html` - About page with nested directory (Test 5)
- `public/products.html` - Data-driven product page (Test 6)
- `public/styles.css` - Stylesheet for products page (Test 8)
- `public/script.js` - Interactive filtering script (Test 9)
- `public/demo.html` - Demo page for metadata testing (Test 13)
- `public/tasks.html` - To-do app HTML (Test 14)
- `public/tasks.css` - To-do app styles (Test 14)
- `public/tasks.js` - To-do app JavaScript (Test 14)
- `public/test.html`, `public/test.css`, `public/test.js` - File type filtering tests (Test 12)
- Test image/PDF files for filtering verification (Test 12)

**Cleanup Instructions:**
To reset test environment:
```bash
# Remove all generated HTML/CSS/JS files
rm -rf public/*.html public/*.css public/*.js

# Remove nested directories
rm -rf public/pages/ public/assets/

# Or reset entire public directory (will remove all files)
rm -rf public/*
```

**Note**: Keep `public/` directory itself (created by Story 1.2). Only remove generated test files.

**Recommended**: Keep generated files for Epic 3 integration testing (React frontend will use these files as examples).

---

## Next Steps After Testing

Once all tests pass:

1. **Mark Story 2.6 as Complete**: Update story status to "Complete"
2. **Verify all 8 tools work together**: Test full workflow using all JSON + file tools
3. **Prepare for Epic 3**: Keep generated HTML/CSS/JS files as reference for React frontend
4. **Consider creating demo sequence**: Use generated files to demonstrate conversational development
5. **Document discoveries**: Note any interesting agent behaviors or tool usage patterns
6. **Epic 2 Complete**: Story 2.6 completes Epic 2 (Agent SDK Integration) ‚úÖ

**Epic 2 Summary** (all stories):
- Story 2.1: Install and Configure Claude Agent SDK ‚úÖ
- Story 2.2: Create Basic Agent Event Loop ‚úÖ
- Story 2.3: Add Response Streaming to Event Loop ‚úÖ
- Story 2.4: Implement Custom Tool: read_json (+ list_json, preview_json discovery tools) ‚úÖ
- Story 2.5: Implement Custom Tool: write_json ‚úÖ
- Story 2.6: Implement Custom Tools: list_files, preview_file, read_file, write_file ‚úÖ

**All 8 domain-agnostic tools now complete:**
- `/data` directory: list_json, preview_json, read_json, write_json
- `/public` directory: list_files, preview_file, read_file, write_file

**Next Epic**: Epic 3 (React Frontend with Chat Interface)

---

*Generated by Taylor (SAT Guide Creator) from Story 2.6*
