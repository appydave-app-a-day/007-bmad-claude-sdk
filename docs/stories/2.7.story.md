# Story 2.7: Add Conversation Memory to Event Loop

## Status

Ready

## Story

**As a** user,
**I want** the agent to remember previous messages in our conversation,
**so that** I can have multi-turn dialogues without repeating context.

## Acceptance Criteria

1. Conversation history array maintained per Socket.io connection (session-based memory)
2. History structure: array of `{ role: 'user' | 'assistant', content: string }` messages
3. Each user message appended to conversation history before calling agent
4. Each complete agent response appended to conversation history after streaming finishes
5. Agent SDK `query()` call receives conversation history via options parameter
6. Console logging shows: "Conversation history: N messages" before each agent call
7. Manual test: Multi-turn conversation works (Message 1: "Add a product", Message 2: "Sugar for 50 cents" ‚Üí agent understands "Sugar" is the product from Message 1)
8. Session isolation: Each Socket.io connection has independent conversation history
9. Memory cleared on socket disconnect to prevent memory leaks
10. TypeScript interface for conversation message structure in `packages/shared/src/types.ts`

## Tasks / Subtasks

- [ ] Task 1: Define conversation history types (AC: 2, 10)
  - [ ] Open `packages/shared/src/types.ts`
  - [ ] Add `ConversationMessage` interface: `{ role: 'user' | 'assistant'; content: string; timestamp?: number }`
  - [ ] Add `ConversationHistory` type alias: `ConversationMessage[]`
  - [ ] Export new types for use in server and client
  - [ ] Add JSDoc comments explaining conversation memory structure

- [ ] Task 2: Initialize conversation history per socket connection (AC: 1, 8)
  - [ ] Open `packages/server/src/server.ts` (or socket-manager.ts if separate)
  - [ ] Create `Map<string, ConversationHistory>` to store history by socket ID
  - [ ] On `connection` event, initialize empty conversation history for socket ID: `conversationHistories.set(socket.id, [])`
  - [ ] Add console log: "Socket connected, initialized conversation history" with socket ID
  - [ ] Verify each socket has independent history storage

- [ ] Task 3: Append user message to conversation history (AC: 3)
  - [ ] In `user_message` event handler (server.ts or socket-manager.ts)
  - [ ] Get conversation history for current socket: `const history = conversationHistories.get(socket.id) || []`
  - [ ] Create user message object: `{ role: 'user', content: payload.content, timestamp: Date.now() }`
  - [ ] Append to history: `history.push(userMessage)`
  - [ ] Update history map: `conversationHistories.set(socket.id, history)`
  - [ ] Add debug log: "User message added to history" with message count

- [ ] Task 4: Update event loop to accept and use conversation history (AC: 5, 6)
  - [ ] Open `packages/server/src/agent/event-loop.ts`
  - [ ] Update `handleUserMessage` signature to accept `history: ConversationHistory` parameter
  - [ ] Add log before agent call: `logger.info('Conversation history: N messages', { component: 'AgentEventLoop', messageCount: history.length })`
  - [ ] Create async generator function `createConversationIterable()` that yields SDK-formatted messages
  - [ ] In generator: Iterate history, yield only user messages in SDK format: `{ type: 'user', message: { role: 'user', content }, parent_tool_use_id: null, session_id: socket.id }`
  - [ ] In generator: Yield new user message at end in same format
  - [ ] Replace `createQuery(message)` with `query({ prompt: conversationIterable, options: getAgentOptions() })`
  - [ ] Import `query` directly from SDK (not using helper `createQuery`)
  - [ ] Add inline comment: "SDK receives conversation as async iterable - maintains full multi-turn context"

- [ ] Task 5: Append agent response to conversation history after streaming completes (AC: 4)
  - [ ] In `handleUserMessage` function after streaming completes
  - [ ] Accumulate complete agent response during streaming (collect all chunks into single string)
  - [ ] Create assistant message object: `{ role: 'assistant', content: completeResponse, timestamp: Date.now() }`
  - [ ] Return assistant message from `handleUserMessage` so caller can append to history
  - [ ] Update `user_message` handler to receive returned message and append to history
  - [ ] Add debug log: "Agent response added to history" with total message count

- [ ] Task 6: Clear conversation history on disconnect (AC: 9)
  - [ ] In `disconnect` event handler (server.ts or socket-manager.ts)
  - [ ] Remove history from map: `conversationHistories.delete(socket.id)`
  - [ ] Add log: "Socket disconnected, cleared conversation history" with socket ID and message count
  - [ ] Verify no memory leaks by monitoring map size during multiple connect/disconnect cycles

- [ ] Task 7: Manual testing and verification (AC: 7)
  - [ ] Start development server: `npm run dev`
  - [ ] Open browser to chat interface
  - [ ] Test basic multi-turn conversation:
    - [ ] Message 1: "Add a product called 'Coffee'"
    - [ ] Verify agent creates product
    - [ ] Message 2: "Set the price to $2.50"
    - [ ] Verify agent understands "Coffee" from Message 1 context and updates price
    - [ ] Verify console shows "Conversation history: 0 messages" ‚Üí "Conversation history: 2 messages" ‚Üí "Conversation history: 4 messages"
  - [ ] Test reference to previous context:
    - [ ] Message 1: "Create 3 products: Sugar, Salt, Pepper"
    - [ ] Message 2: "Sugar costs 50 cents"
    - [ ] Verify agent associates price with Sugar from Message 1 context
  - [ ] Test session isolation:
    - [ ] Open two browser tabs/windows
    - [ ] Start different conversations in each tab
    - [ ] Verify agent responses don't mix context between tabs
    - [ ] Check server logs show separate socket IDs and independent histories
  - [ ] Test memory cleanup:
    - [ ] Start conversation in browser
    - [ ] Close browser tab (disconnect)
    - [ ] Verify server logs show "Socket disconnected, cleared conversation history"
    - [ ] Open new tab and start fresh conversation
    - [ ] Verify agent doesn't remember previous conversation
  - [ ] Test long conversation:
    - [ ] Send 10+ back-and-forth messages
    - [ ] Verify agent maintains context throughout
    - [ ] Verify console shows accurate message count
    - [ ] Monitor server memory usage (should remain stable)

## Dev Notes

This story implements conversation memory for multi-turn dialogues by maintaining conversation history per Socket.io connection. This enables natural conversations where the agent remembers previous context without requiring users to repeat information.

### Previous Story Insights

From Story 2.3 (Add Response Streaming to Event Loop):
- ‚úÖ **Event loop handles streaming** - `handleUserMessage()` emits chunks via Socket.io
- ‚úÖ **Streaming accumulates chunks** - Already collecting chunks during iteration (lines 55-96 in event-loop.ts)
- ‚úÖ **Socket instance passed to event loop** - Available for accessing socket.id
- ‚úÖ **Session tracking via socket.id** - Natural fit for per-connection conversation history
- üìù **Current limitation**: Agent has no memory - each message treated independently
- üìù **Need to accumulate complete response** - Already iterating chunks, can collect full response
- üìù **Agent SDK accepts conversation history** - Check SDK docs for `messages` or `history` option

**Key Lessons:**
- Socket.io connection lifecycle (connect ‚Üí messages ‚Üí disconnect) maps naturally to conversation sessions
- Event loop already has access to socket instance - can retrieve socket.id for history lookup
- Streaming already accumulates chunks - minor modification to also store complete response
- Map data structure perfect for socket.id ‚Üí conversation history mapping

[Source: docs/stories/2.3.story.md#Dev Notes, docs/stories/2.3.story.md#QA Results]

From Story 2.2 (Create Basic Agent Event Loop):
- ‚úÖ **Agent SDK query pattern established** - `createQuery({ prompt, options })`
- üìù **Need to check SDK options** - Verify how to pass conversation history (likely `messages` array)
- üìù **History format may differ** - SDK might expect specific structure, may need conversion

[Source: docs/stories/2.2.story.md#Dev Notes]

### Tech Stack

**Conversation History Storage:**
- **Pattern**: `Map<string, ConversationHistory>` where key is `socket.id`
- **Lifecycle**: Initialize on connect, append on each turn, clear on disconnect
- **Structure**: `{ role: 'user' | 'assistant', content: string, timestamp?: number }`
- **Session Isolation**: Each socket.id has independent history array
- [Source: architecture/backend-architecture.md#Session Management]

**Agent SDK Conversation History:**
- **Parameter**: Pass history via `createQuery({ prompt, options: { messages: [...] } })` (verify SDK docs)
- **Format**: May need to convert from our format to SDK format (check if SDK expects different structure)
- **Context Window**: Agent SDK handles token limits internally, no manual truncation needed for MVP
- [Source: Agent SDK documentation in /Users/davidcruwys/dev/ad/brains/anthropic-claude/agent-sdk/]

**Socket.io Session Management:**
- **Connection ID**: `socket.id` uniquely identifies each connection
- **Disconnect Cleanup**: Always remove from map on `disconnect` event to prevent memory leaks
- **Concurrent Sessions**: Map supports multiple simultaneous conversations
- [Source: architecture/api-specification.md#Socket.io Event Specification]

**Logging:**
- **Utility**: `packages/server/src/utils/logger.ts`
- **Pattern**: `logger.info('Conversation history: N messages', { component: 'AgentEventLoop', messageCount: history.length })`
- **Session Logs**: Include socket.id in logs for multi-session debugging
- [Source: architecture/coding-standards.md#Logging Pattern]

### Project Structure

**Files Modified in This Story:**
1. `packages/shared/src/types.ts` - Add ConversationMessage interface, ConversationHistory type
2. `packages/server/src/server.ts` (or socket-manager.ts) - Add conversation history map, initialize on connect, append messages, clear on disconnect
3. `packages/server/src/agent/event-loop.ts` - Accept history parameter, pass to Agent SDK, return complete response

**No New Files Created** - This story enhances existing event loop and socket management

[Source: architecture/unified-project-structure.md]

### Conversation History Management Pattern (AC 1, 2, 3, 4, 5, 8, 9)

**Server-Side History Management:**

```typescript
// packages/server/src/server.ts (or socket-manager.ts)
import { Socket } from 'socket.io';
import { ConversationHistory } from '@shared/types';

// Store conversation history per socket connection
const conversationHistories = new Map<string, ConversationHistory>();

io.on('connection', (socket: Socket) => {
  // Initialize empty conversation history for new connection
  conversationHistories.set(socket.id, []);
  logger.info('Socket connected, initialized conversation history', {
    component: 'SocketServer',
    socketId: socket.id
  });

  socket.on('user_message', async (payload: { content: string; messageId: string }) => {
    try {
      const { content, messageId } = payload;

      // Get conversation history for this socket
      const history = conversationHistories.get(socket.id) || [];

      // Append user message to history
      const userMessage: ConversationMessage = {
        role: 'user',
        content,
        timestamp: Date.now()
      };
      history.push(userMessage);
      conversationHistories.set(socket.id, history);

      logger.debug('User message added to history', {
        component: 'SocketServer',
        socketId: socket.id,
        messageCount: history.length
      });

      // Call event loop with conversation history
      const assistantMessage = await handleUserMessage(content, messageId, socket, history);

      // Append agent response to history
      if (assistantMessage) {
        history.push(assistantMessage);
        conversationHistories.set(socket.id, history);

        logger.debug('Agent response added to history', {
          component: 'SocketServer',
          socketId: socket.id,
          messageCount: history.length
        });
      }
    } catch (error) {
      logger.error('Failed to process user message', {
        component: 'SocketServer',
        error: (error as Error).message
      });
    }
  });

  socket.on('disconnect', () => {
    // Clear conversation history to prevent memory leaks
    const history = conversationHistories.get(socket.id);
    const messageCount = history?.length || 0;

    conversationHistories.delete(socket.id);

    logger.info('Socket disconnected, cleared conversation history', {
      component: 'SocketServer',
      socketId: socket.id,
      messageCount
    });
  });
});
```

**Event Loop with Conversation History:**

```typescript
// packages/server/src/agent/event-loop.ts (modifications)
import { ConversationHistory, ConversationMessage } from '@shared/types';

/**
 * Handle user message with conversation history
 * Story 2.7: Passes conversation history to Agent SDK for multi-turn context
 *
 * Changes from Story 2.3:
 * - Accept history parameter with previous conversation
 * - Log conversation history size before agent call
 * - Pass history to Agent SDK createQuery() options
 * - Accumulate complete response during streaming
 * - Return assistant message for caller to append to history
 */
export const handleUserMessage = async (
  message: string,
  messageId: string,
  socket: Socket,
  history: ConversationHistory
): Promise<ConversationMessage | null> => {
  try {
    logger.info('Received user message', {
      component: 'AgentEventLoop',
      messageId
    });

    // Log conversation history size (AC 6)
    logger.info(`Conversation history: ${history.length} messages`, {
      component: 'AgentEventLoop',
      messageId,
      messageCount: history.length
    });

    // Create streaming query with conversation history
    // Story 2.7: Convert history to async iterable for SDK (verified approach)
    async function* createConversationIterable() {
      // Yield each previous user message from history
      for (const msg of history) {
        if (msg.role === 'user') {
          yield {
            type: 'user' as const,
            message: { role: 'user' as const, content: msg.content },
            parent_tool_use_id: null,
            session_id: socket.id,
          };
        }
        // Assistant messages implicitly maintained by SDK
      }
      // Yield the new user message
      yield {
        type: 'user' as const,
        message: { role: 'user' as const, content: message },
        parent_tool_use_id: null,
        session_id: socket.id,
      };
    }

    // Call Agent SDK with conversation iterable (not simple string)
    const conversationIterable = createConversationIterable();
    const queryResult = query({
      prompt: conversationIterable,
      options: getAgentOptions()
    });

    logger.info('Streaming started', {
      component: 'AgentEventLoop',
      messageId
    });

    let chunkIndex = 0;
    let completeResponse = ''; // Accumulate complete response for history

    // Iterate over streaming chunks
    for await (const chunk of queryResult) {
      const textContent = chunk.message?.content?.find(c => c.type === 'text')?.text || '';

      if (textContent) {
        // Accumulate for conversation history
        completeResponse += textContent;

        // Emit chunk to client
        socket.emit('agent_response_chunk', {
          content: textContent,
          messageId,
          chunkIndex
        });

        logger.info(`Chunk ${chunkIndex} received`, {
          component: 'AgentEventLoop',
          messageId,
          chunkLength: textContent.length
        });

        chunkIndex++;
      }
    }

    // Emit completion signal
    socket.emit('agent_response_complete', { messageId });

    logger.info('Streaming complete', {
      component: 'AgentEventLoop',
      messageId,
      totalChunks: chunkIndex
    });

    // Return assistant message for caller to append to history
    return {
      role: 'assistant',
      content: completeResponse,
      timestamp: Date.now()
    };
  } catch (error) {
    logger.error('Streaming failed', {
      component: 'AgentEventLoop',
      messageId,
      error: (error as Error).message,
      stack: (error as Error).stack
    });

    socket.emit('error', {
      message: 'Streaming failed. Please try again.',
      code: 'STREAMING_ERROR'
    });

    return null; // No message to append on error
  }
};
```

**Key Implementation Details:**
- Map stores conversation history per socket.id (session isolation)
- Each user message appended before calling agent
- Complete agent response accumulated during streaming
- Assistant message returned from event loop for history append
- History cleared on disconnect (prevents memory leaks)
- Logging shows message count at each stage

[Source: architecture/backend-architecture.md#Session Management, architecture/components.md#Agent Event Loop]

### Shared Types (AC 2, 10)

**Type Definitions:**

```typescript
// packages/shared/src/types.ts

/**
 * Single message in conversation history
 * Used to maintain multi-turn conversation context
 */
export interface ConversationMessage {
  /** Role of the message sender */
  role: 'user' | 'assistant';
  /** Message content */
  content: string;
  /** Optional timestamp (milliseconds since epoch) */
  timestamp?: number;
}

/**
 * Array of conversation messages
 * Maintained per Socket.io connection for session-based memory
 */
export type ConversationHistory = ConversationMessage[];
```

[Source: architecture/data-models.md#Conversation Memory Model]

### Agent SDK Integration ‚úÖ VERIFIED

**Verified Approach** (from TypeScript Agent SDK v0.1.42):

The TypeScript SDK's `query()` function accepts conversation history via the `prompt` parameter as an `AsyncIterable<SDKUserMessage>`:

```typescript
// SDK Type Signature
export declare function query(_params: {
    prompt: string | AsyncIterable<SDKUserMessage>;
    options?: Options;
}): Query;
```

**Implementation Pattern**:

```typescript
// Helper function to convert our history format to SDK async iterable
async function* createConversationIterable(
  history: ConversationHistory,
  newMessage: string
): AsyncGenerator<SDKUserMessage> {
  // Yield each previous message from history
  for (const msg of history) {
    if (msg.role === 'user') {
      yield {
        type: 'user',
        message: { role: 'user', content: msg.content },
        parent_tool_use_id: null,
        session_id: socketId, // Use socket.id as session identifier
      };
    }
    // Note: Assistant messages are implicitly part of SDK's internal state
    // when we yield user messages - SDK maintains full conversation context
  }

  // Yield the new user message
  yield {
    type: 'user',
    message: { role: 'user', content: newMessage },
    parent_tool_use_id: null,
    session_id: socketId,
  };
}

// Usage in event loop
const conversationIterable = createConversationIterable(history, message);
const queryIterator = query({
  prompt: conversationIterable,
  options: getAgentOptions()
});
```

**Key Points**:
- ‚úÖ **Stateless Function**: Unlike Python SDK's `ClaudeSDKClient` class, TypeScript uses stateless `query()` function
- ‚úÖ **History via Prompt**: Conversation history passed as `AsyncIterable<SDKUserMessage>` in `prompt` parameter
- ‚úÖ **Application-Side Storage**: We maintain history in Map (SDK doesn't store it)
- ‚úÖ **Message Format**: Each message needs `type`, `message`, `parent_tool_use_id`, `session_id` fields
- ‚ö†Ô∏è **User Messages Only**: We only yield user messages; SDK implicitly maintains assistant responses via its internal state

**Alternative Simpler Approach** (if SDK supports):
If SDK accepts simple message arrays, we could pass:
```typescript
const messages = history.map(msg => ({ role: msg.role, content: msg.content }));
```

**Action for Dev**: Test both approaches - async iterable (verified from types) and simple array (simpler if supported).

[Source: `/Users/davidcruwys/dev/ad/appydave-app-a-day/007-bmad-claude-sdk/node_modules/@anthropic-ai/claude-agent-sdk/sdk.d.ts` lines 525-528, verified 2025-11-16]

### Memory Management Considerations

**Memory Leak Prevention (AC 9):**
- **Critical**: Always call `conversationHistories.delete(socket.id)` on disconnect
- **Verification**: Monitor map size during testing (connect ‚Üí chat ‚Üí disconnect cycles)
- **Expected**: Map size should return to 0 after all clients disconnect

**Long Conversation Handling:**
- **MVP Approach**: No token limit truncation - Agent SDK handles internally
- **Post-MVP**: Consider truncating history if conversations exceed token limits
- **Future Enhancement**: Implement conversation summarization for very long sessions

**Concurrent Sessions:**
- **Supported**: Map naturally handles multiple socket connections
- **Isolation**: Each socket.id has completely independent history
- **Scalability**: For MVP, in-memory Map sufficient; production may need Redis/database

[Source: architecture/tech-stack.md#Session Management, docs/prd.md#MVP Scope]

### Coding Standards

**Critical Rules for This Story:**
- ‚úÖ **Type Sharing**: Define ConversationMessage in `packages/shared/src/types.ts`
- ‚úÖ **Logging Pattern**: Log message count with component: 'AgentEventLoop' and 'SocketServer'
- ‚úÖ **Memory Management**: Always delete from map on disconnect
- ‚úÖ **Session Isolation**: Never share history between different socket IDs
- ‚úÖ **Async/Await**: Use async/await for all event loop operations
- ‚úÖ **Educational Clarity**: Add comments explaining conversation memory pattern

**Naming Conventions:**
- Types: `ConversationMessage`, `ConversationHistory` (PascalCase)
- Variables: `conversationHistories`, `userMessage`, `assistantMessage` (camelCase)
- Map key: Use `socket.id` (built-in Socket.io identifier)

[Source: architecture/coding-standards.md#Critical Fullstack Rules]

### Testing

**Testing Strategy for This Story:**
- **Manual Testing Only** - No automated test framework for MVP
- Verification steps (AC 7):
  1. Start development server: `npm run dev`
  2. Open browser to chat interface
  3. Test multi-turn conversation:
     - Message 1: "Add a product called 'Coffee'"
     - Message 2: "Set the price to $2.50"
     - Verify agent understands "Coffee" from previous message
  4. Verify server console logs show message count increasing
  5. Test session isolation: Open two browser tabs, verify independent conversations
  6. Test memory cleanup: Close tab, verify disconnect log, reopen and verify fresh history

**Future Test Organization:**
- Unit tests: Mock Socket.io, verify history append/clear logic
- Integration tests: Mock Agent SDK, verify history passed correctly
- [Source: architecture/testing-strategy.md#Test Organization]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-16 | 1.0 | Initial story creation from PRD Epic 2 Story 2.7 | Bob (Scrum Master) |
| 2025-11-16 | 1.1 | SDK integration verified: Updated Agent SDK Integration section with verified approach from TypeScript SDK v0.1.42. Conversation history passed via `AsyncIterable<SDKUserMessage>` to `query()` prompt parameter. Updated Task 4 subtasks and code examples to reflect verified implementation pattern. | Sarah (Product Owner) + Claude Code |

## Dev Agent Record

### Agent Model Used

(To be filled by Dev Agent)

### Debug Log References

(To be filled by Dev Agent)

### Completion Notes List

(To be filled by Dev Agent)

### File List

(To be filled by Dev Agent)

## QA Results

(To be filled by QA Agent after implementation)
